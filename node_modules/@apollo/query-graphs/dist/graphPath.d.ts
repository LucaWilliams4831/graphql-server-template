import { NamedType, OperationElement, Schema, SchemaRootKind, SelectionSet, ObjectType, DeferDirectiveArgs } from "@apollo/federation-internals";
import { OpPathTree } from "./pathTree";
import { Vertex, QueryGraph, Edge, RootVertex } from "./querygraph";
import { Transition } from "./transition";
import { PathContext } from "./pathContext";
export declare class GraphPath<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never> implements Iterable<[Edge | TNullEdge, TTrigger, OpPathTree | null]> {
    private readonly props;
    private constructor();
    get graph(): QueryGraph;
    get root(): RV;
    get tail(): Vertex;
    get deferOnTail(): DeferDirectiveArgs | undefined;
    get subgraphEnteringEdge(): {
        index: number;
        edge: Edge;
        cost: number;
    } | undefined;
    static create<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never>(graph: QueryGraph, root: RV): GraphPath<TTrigger, RV, TNullEdge>;
    static fromGraphRoot<TTrigger, TNullEdge extends null | never = never>(graph: QueryGraph, rootKind: SchemaRootKind): RootPath<TTrigger, TNullEdge> | undefined;
    get size(): number;
    subgraphJumps(): number;
    [Symbol.iterator](): PathIterator<TTrigger, TNullEdge>;
    lastEdge(): Edge | TNullEdge | undefined;
    lastTrigger(): TTrigger | undefined;
    tailPossibleRuntimeTypes(): readonly ObjectType[];
    lastIsIntefaceObjectFakeDownCastAfterEnteringSubgraph(): boolean;
    private lastIsInterfaceObjectFakeDownCast;
    add(trigger: TTrigger, edge: Edge | TNullEdge, conditionsResolution: ConditionResolution, defer?: DeferDirectiveArgs): GraphPath<TTrigger, RV, TNullEdge>;
    concat(tailPath: GraphPath<TTrigger, Vertex, TNullEdge>): GraphPath<TTrigger, RV, TNullEdge>;
    checkDirectPathFromPreviousSubgraphTo(typeName: string, triggerToEdge: (graph: QueryGraph, vertex: Vertex, t: TTrigger) => Edge | null | undefined): Vertex | undefined;
    nextEdges(): readonly Edge[];
    isTerminal(): boolean;
    isRootPath(): this is RootPath<TTrigger, TNullEdge>;
    mapMainPath<T>(mapper: (e: Edge | TNullEdge, pathIdx: number) => T): T[];
    private edgeAt;
    reduceMainPath<T>(reducer: (accumulator: T, edge: Edge | TNullEdge, pathIdx: number) => T, initialValue: T): T;
    hasJustCycled(): boolean;
    hasAnyEdgeConditions(): boolean;
    isOnTopLevelQueryRoot(): boolean;
    truncateTrailingDowncasts(): GraphPath<TTrigger, RV, TNullEdge>;
    markOverridding(otherOptions: GraphPath<TTrigger, RV, TNullEdge>[][]): {
        thisPath: GraphPath<TTrigger, RV, TNullEdge>;
        otherOptions: GraphPath<TTrigger, RV, TNullEdge>[][];
    };
    isOverriddenBy(otherPath: GraphPath<TTrigger, RV, TNullEdge>): boolean;
    tailIsInterfaceObject(): boolean;
    toString(): string;
}
export interface PathIterator<TTrigger, TNullEdge extends null | never = never> extends Iterator<[Edge | TNullEdge, TTrigger, OpPathTree | null]> {
    currentIndex: number;
    currentVertex: Vertex;
}
export type RootPath<TTrigger, TNullEdge extends null | never = never> = GraphPath<TTrigger, RootVertex, TNullEdge>;
export type OpTrigger = OperationElement | PathContext;
export type OpGraphPath<RV extends Vertex = Vertex> = GraphPath<OpTrigger, RV, null>;
export type OpRootPath = OpGraphPath<RootVertex>;
export declare function isRootPath(path: OpGraphPath<any>): path is OpRootPath;
export declare function terminateWithNonRequestedTypenameField<V extends Vertex>(path: OpGraphPath<V>): OpGraphPath<V>;
export declare function traversePath(path: GraphPath<any>, onEdges: (edge: Edge) => void): void;
export type ConditionResolver = (edge: Edge, context: PathContext, excludedEdges: ExcludedEdges, excludedConditions: ExcludedConditions) => ConditionResolution;
export type ConditionResolution = {
    satisfied: boolean;
    cost: number;
    pathTree?: OpPathTree;
    unsatisfiedConditionReason?: UnsatisfiedConditionReason;
};
export declare enum UnsatisfiedConditionReason {
    NO_POST_REQUIRE_KEY = 0
}
export declare const noConditionsResolution: ConditionResolution;
export declare const unsatisfiedConditionsResolution: ConditionResolution;
export declare enum UnadvanceableReason {
    UNSATISFIABLE_KEY_CONDITION = 0,
    UNSATISFIABLE_REQUIRES_CONDITION = 1,
    UNRESOLVABLE_INTERFACE_OBJECT = 2,
    NO_MATCHING_TRANSITION = 3,
    UNREACHABLE_TYPE = 4,
    IGNORED_INDIRECT_PATH = 5
}
export type Unadvanceable = {
    sourceSubgraph: string;
    destSubgraph: string;
    reason: UnadvanceableReason;
    details: string;
};
export declare class Unadvanceables {
    readonly reasons: Unadvanceable[];
    constructor(reasons: Unadvanceable[]);
    toString(): string;
}
export declare function isUnadvanceable(result: any[] | Unadvanceables): result is Unadvanceables;
export declare class TransitionPathWithLazyIndirectPaths<V extends Vertex = Vertex> {
    readonly path: GraphPath<Transition, V>;
    readonly conditionResolver: ConditionResolver;
    private lazilyComputedIndirectPaths;
    constructor(path: GraphPath<Transition, V>, conditionResolver: ConditionResolver);
    static initial<V extends Vertex = Vertex>(initialPath: GraphPath<Transition, V>, conditionResolver: ConditionResolver): TransitionPathWithLazyIndirectPaths<V>;
    indirectOptions(): IndirectPaths<Transition, V>;
    private computeIndirectPaths;
    toString(): string;
}
export declare function advancePathWithTransition<V extends Vertex>(subgraphPath: TransitionPathWithLazyIndirectPaths<V>, transition: Transition, targetType: NamedType): TransitionPathWithLazyIndirectPaths<V>[] | Unadvanceables;
export type ExcludedEdges = readonly [number, number][];
export declare function sameExcludedEdges(ex1: ExcludedEdges, ex2: ExcludedEdges): boolean;
export type ExcludedConditions = readonly SelectionSet[];
export declare function addConditionExclusion(excluded: ExcludedConditions, newExclusion: SelectionSet | undefined): ExcludedConditions;
export type IndirectPaths<TTrigger, V extends Vertex = Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables> = {
    paths: GraphPath<TTrigger, V, TNullEdge>[];
    deadEnds: TDeadEnds;
};
export declare function getLocallySatisfiableKey(graph: QueryGraph, typeVertex: Vertex): SelectionSet | undefined;
export type SimultaneousPaths<V extends Vertex = Vertex> = OpGraphPath<V>[];
type OpIndirectPaths<V extends Vertex> = IndirectPaths<OpTrigger, V, null, never>;
export declare class SimultaneousPathsWithLazyIndirectPaths<V extends Vertex = Vertex> {
    readonly paths: SimultaneousPaths<V>;
    readonly context: PathContext;
    readonly conditionResolver: ConditionResolver;
    readonly excludedNonCollectingEdges: ExcludedEdges;
    readonly excludedConditionsOnNonCollectingEdges: ExcludedConditions;
    private lazilyComputedIndirectPaths;
    constructor(paths: SimultaneousPaths<V>, context: PathContext, conditionResolver: ConditionResolver, excludedNonCollectingEdges?: ExcludedEdges, excludedConditionsOnNonCollectingEdges?: ExcludedConditions);
    indirectOptions(updatedContext: PathContext, pathIdx: number): OpIndirectPaths<V>;
    private computeIndirectPaths;
    toString(): string;
}
export declare function simultaneousPathsToString(simultaneousPaths: SimultaneousPaths<any> | SimultaneousPathsWithLazyIndirectPaths<any>, indentOnNewLine?: string): string;
export declare function advanceOptionsToString(options: (SimultaneousPaths<any> | SimultaneousPathsWithLazyIndirectPaths<any> | GraphPath<any>)[] | undefined): string;
export declare function advanceSimultaneousPathsWithOperation<V extends Vertex>(supergraphSchema: Schema, subgraphSimultaneousPaths: SimultaneousPathsWithLazyIndirectPaths<V>, operation: OperationElement): SimultaneousPathsWithLazyIndirectPaths<V>[] | undefined;
export declare function createInitialOptions<V extends Vertex>(initialPath: OpGraphPath<V>, initialContext: PathContext, conditionResolver: ConditionResolver, excludedEdges: ExcludedEdges, excludedConditions: ExcludedConditions): SimultaneousPathsWithLazyIndirectPaths<V>[];
export {};
//# sourceMappingURL=graphPath.d.ts.map