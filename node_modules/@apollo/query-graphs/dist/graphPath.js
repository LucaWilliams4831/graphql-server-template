"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInitialOptions = exports.advanceSimultaneousPathsWithOperation = exports.advanceOptionsToString = exports.simultaneousPathsToString = exports.SimultaneousPathsWithLazyIndirectPaths = exports.getLocallySatisfiableKey = exports.addConditionExclusion = exports.sameExcludedEdges = exports.advancePathWithTransition = exports.TransitionPathWithLazyIndirectPaths = exports.isUnadvanceable = exports.Unadvanceables = exports.UnadvanceableReason = exports.unsatisfiedConditionsResolution = exports.noConditionsResolution = exports.UnsatisfiedConditionReason = exports.traversePath = exports.terminateWithNonRequestedTypenameField = exports.isRootPath = exports.GraphPath = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const pathTree_1 = require("./pathTree");
const querygraph_1 = require("./querygraph");
const transition_1 = require("./transition");
const pathContext_1 = require("./pathContext");
const uuid_1 = require("uuid");
const debug = (0, federation_internals_1.newDebugLogger)('path');
function updateRuntimeTypes(currentRuntimeTypes, edge) {
    var _a;
    if (!edge) {
        return currentRuntimeTypes;
    }
    switch (edge.transition.kind) {
        case 'FieldCollection':
            const field = edge.transition.definition;
            if (!(0, federation_internals_1.isCompositeType)((0, federation_internals_1.baseType)(field.type))) {
                return [];
            }
            const newRuntimeTypes = [];
            for (const parentType of currentRuntimeTypes) {
                const fieldType = (_a = parentType.field(field.name)) === null || _a === void 0 ? void 0 : _a.type;
                if (fieldType) {
                    for (const type of (0, federation_internals_1.possibleRuntimeTypes)((0, federation_internals_1.baseType)(fieldType))) {
                        if (!newRuntimeTypes.includes(type)) {
                            newRuntimeTypes.push(type);
                        }
                    }
                }
            }
            return newRuntimeTypes;
        case 'DownCast':
            const castedType = edge.transition.castedType;
            const castedRuntimeTypes = (0, federation_internals_1.possibleRuntimeTypes)(castedType);
            return currentRuntimeTypes.filter(t => castedRuntimeTypes.includes(t));
        case 'InterfaceObjectFakeDownCast':
            return currentRuntimeTypes;
        case 'KeyResolution':
            const currentType = edge.tail.type;
            return (0, federation_internals_1.possibleRuntimeTypes)(currentType);
        case 'RootTypeResolution':
        case 'SubgraphEnteringTransition':
            (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(edge.tail.type), () => `Query edge should be between object type but got ${edge}`);
            return [edge.tail.type];
    }
}
function withReplacedLastElement(arr, newLast) {
    (0, federation_internals_1.assert)(arr.length > 0, 'Should not have been called on empty array');
    const newArr = new Array(arr.length);
    for (let i = 0; i < arr.length - 1; i++) {
        newArr[i] = arr[i];
    }
    newArr[arr.length - 1] = newLast;
    return newArr;
}
class GraphPath {
    constructor(props) {
        this.props = props;
    }
    get graph() {
        return this.props.graph;
    }
    get root() {
        return this.props.root;
    }
    get tail() {
        return this.props.tail;
    }
    get deferOnTail() {
        return this.props.deferOnTail;
    }
    get subgraphEnteringEdge() {
        return this.props.subgraphEnteringEdge;
    }
    static create(graph, root) {
        const runtimeTypes = (0, querygraph_1.isFederatedGraphRootType)(root.type) ? [] : (0, federation_internals_1.possibleRuntimeTypes)(root.type);
        return new GraphPath({
            graph,
            root,
            tail: root,
            edgeTriggers: [],
            edgeIndexes: [],
            edgeConditions: [],
            ownPathIds: [],
            overriddingPathIds: [],
            runtimeTypesOfTail: runtimeTypes,
        });
    }
    static fromGraphRoot(graph, rootKind) {
        const root = graph.root(rootKind);
        return root ? this.create(graph, root) : undefined;
    }
    get size() {
        return this.props.edgeIndexes.length;
    }
    subgraphJumps() {
        let jumps = 0;
        let v = this.root;
        for (let i = 0; i < this.size; i++) {
            const edge = this.edgeAt(i, v);
            if (!edge) {
                continue;
            }
            if (edge.transition.kind === 'KeyResolution' || edge.transition.kind === 'RootTypeResolution') {
                ++jumps;
            }
            v = edge.tail;
        }
        return jumps;
    }
    [Symbol.iterator]() {
        const path = this;
        return {
            currentIndex: 0,
            currentVertex: this.root,
            next() {
                if (this.currentIndex >= path.size) {
                    return { done: true, value: undefined };
                }
                const idx = this.currentIndex++;
                const edge = path.edgeAt(idx, this.currentVertex);
                if (edge) {
                    this.currentVertex = edge.tail;
                }
                return { done: false, value: [edge, path.props.edgeTriggers[idx], path.props.edgeConditions[idx]] };
            }
        };
    }
    lastEdge() {
        return this.props.edgeToTail;
    }
    lastTrigger() {
        return this.props.edgeTriggers[this.size - 1];
    }
    tailPossibleRuntimeTypes() {
        return this.props.runtimeTypesOfTail;
    }
    lastIsIntefaceObjectFakeDownCastAfterEnteringSubgraph() {
        var _a;
        return this.lastIsInterfaceObjectFakeDownCast()
            && ((_a = this.subgraphEnteringEdge) === null || _a === void 0 ? void 0 : _a.index) === this.size - 2;
    }
    lastIsInterfaceObjectFakeDownCast() {
        var _a;
        return ((_a = this.lastEdge()) === null || _a === void 0 ? void 0 : _a.transition.kind) === 'InterfaceObjectFakeDownCast';
    }
    add(trigger, edge, conditionsResolution, defer) {
        var _a, _b, _c, _d;
        (0, federation_internals_1.assert)(!edge || this.tail.index === edge.head.index, () => `Cannot add edge ${edge} to path ending at ${this.tail}`);
        (0, federation_internals_1.assert)(conditionsResolution.satisfied, 'Should add to a path if the conditions cannot be satisfied');
        (0, federation_internals_1.assert)(!edge || edge.conditions || !conditionsResolution.pathTree, () => `Shouldn't have conditions paths (got ${conditionsResolution.pathTree}) for edge without conditions (edge: ${edge})`);
        let subgraphEnteringEdge = this.subgraphEnteringEdge;
        if (edge) {
            if (edge.transition.kind === 'DownCast' && this.props.edgeToTail) {
                const previousOperation = this.lastTrigger();
                if (previousOperation instanceof federation_internals_1.FragmentElement && previousOperation.appliedDirectives.length === 0) {
                    const runtimeTypesWithoutPreviousCast = updateRuntimeTypes(this.props.runtimeTypesBeforeTailIfLastIsCast, edge);
                    if (runtimeTypesWithoutPreviousCast.length > 0
                        && runtimeTypesWithoutPreviousCast.every(t => this.props.runtimeTypesOfTail.includes(t))) {
                        const updatedEdge = this.graph.outEdges(this.props.edgeToTail.head).find(e => e.tail.type === edge.tail.type);
                        if (updatedEdge) {
                            debug.log(() => `Previous cast ${previousOperation} is made obsolete by new cast ${trigger}, removing from path.`);
                            return new GraphPath({
                                ...this.props,
                                tail: updatedEdge.tail,
                                edgeTriggers: withReplacedLastElement(this.props.edgeTriggers, trigger),
                                edgeIndexes: withReplacedLastElement(this.props.edgeIndexes, updatedEdge.index),
                                edgeConditions: withReplacedLastElement(this.props.edgeConditions, (_a = conditionsResolution.pathTree) !== null && _a !== void 0 ? _a : null),
                                edgeToTail: updatedEdge,
                                runtimeTypesOfTail: runtimeTypesWithoutPreviousCast,
                                deferOnTail: defer !== null && defer !== void 0 ? defer : this.props.deferOnTail,
                            });
                        }
                    }
                }
            }
            if (edge.isKeyOrRootTypeEdgeToSelf()) {
                subgraphEnteringEdge = undefined;
            }
            else if (edge.transition.kind === 'KeyResolution') {
                subgraphEnteringEdge = {
                    index: this.size,
                    edge,
                    cost: conditionsResolution.cost,
                };
                if (this.lastIsInterfaceObjectFakeDownCast() && (0, federation_internals_1.isInterfaceType)(edge.tail.type)) {
                    return new GraphPath({
                        ...this.props,
                        tail: edge.tail,
                        edgeTriggers: withReplacedLastElement(this.props.edgeTriggers, trigger),
                        edgeIndexes: withReplacedLastElement(this.props.edgeIndexes, edge.index),
                        edgeConditions: withReplacedLastElement(this.props.edgeConditions, (_b = conditionsResolution.pathTree) !== null && _b !== void 0 ? _b : null),
                        subgraphEnteringEdge,
                        edgeToTail: edge,
                        runtimeTypesOfTail: updateRuntimeTypes(this.props.runtimeTypesOfTail, edge),
                        runtimeTypesBeforeTailIfLastIsCast: undefined,
                        deferOnTail: defer,
                    });
                }
            }
        }
        return new GraphPath({
            ...this.props,
            tail: edge ? edge.tail : this.tail,
            edgeTriggers: this.props.edgeTriggers.concat(trigger),
            edgeIndexes: this.props.edgeIndexes.concat((edge ? edge.index : null)),
            edgeConditions: this.props.edgeConditions.concat((_c = conditionsResolution.pathTree) !== null && _c !== void 0 ? _c : null),
            subgraphEnteringEdge,
            edgeToTail: edge,
            runtimeTypesOfTail: updateRuntimeTypes(this.props.runtimeTypesOfTail, edge),
            runtimeTypesBeforeTailIfLastIsCast: ((_d = edge === null || edge === void 0 ? void 0 : edge.transition) === null || _d === void 0 ? void 0 : _d.kind) === 'DownCast' ? this.props.runtimeTypesOfTail : undefined,
            deferOnTail: defer !== null && defer !== void 0 ? defer : (edge && edge.transition.kind === 'DownCast' ? this.props.deferOnTail : undefined),
        });
    }
    concat(tailPath) {
        var _a, _b;
        (0, federation_internals_1.assert)(this.tail.index === tailPath.root.index, () => `Cannot concat ${tailPath} after ${this}`);
        if (tailPath.size === 0) {
            return this;
        }
        let prevRuntimeTypes = this.props.runtimeTypesBeforeTailIfLastIsCast;
        let runtimeTypes = this.props.runtimeTypesOfTail;
        for (const [edge] of tailPath) {
            prevRuntimeTypes = runtimeTypes;
            runtimeTypes = updateRuntimeTypes(runtimeTypes, edge);
        }
        return new GraphPath({
            ...this.props,
            tail: tailPath.tail,
            edgeTriggers: this.props.edgeTriggers.concat(tailPath.props.edgeTriggers),
            edgeIndexes: this.props.edgeIndexes.concat(tailPath.props.edgeIndexes),
            edgeConditions: this.props.edgeConditions.concat(tailPath.props.edgeConditions),
            subgraphEnteringEdge: tailPath.subgraphEnteringEdge ? tailPath.subgraphEnteringEdge : this.subgraphEnteringEdge,
            ownPathIds: this.props.ownPathIds.concat(tailPath.props.ownPathIds),
            overriddingPathIds: this.props.overriddingPathIds.concat(tailPath.props.overriddingPathIds),
            edgeToTail: tailPath.props.edgeToTail,
            runtimeTypesOfTail: runtimeTypes,
            runtimeTypesBeforeTailIfLastIsCast: ((_b = (_a = tailPath.props.edgeToTail) === null || _a === void 0 ? void 0 : _a.transition) === null || _b === void 0 ? void 0 : _b.kind) === 'DownCast' ? prevRuntimeTypes : undefined,
            deferOnTail: tailPath.deferOnTail,
        });
    }
    checkDirectPathFromPreviousSubgraphTo(typeName, triggerToEdge) {
        const enteringEdge = this.subgraphEnteringEdge;
        if (!enteringEdge) {
            return undefined;
        }
        let prevSubgraphVertex = enteringEdge.edge.head;
        for (let i = enteringEdge.index + 1; i < this.size; i++) {
            const triggerToMatch = this.props.edgeTriggers[i];
            const prevSubgraphMatchingEdge = triggerToEdge(this.graph, prevSubgraphVertex, triggerToMatch);
            if (prevSubgraphMatchingEdge === null) {
                continue;
            }
            if (!prevSubgraphMatchingEdge || prevSubgraphMatchingEdge.conditions) {
                return undefined;
            }
            prevSubgraphVertex = prevSubgraphMatchingEdge.tail;
        }
        return prevSubgraphVertex.type.name === typeName ? prevSubgraphVertex : undefined;
    }
    nextEdges() {
        if (this.deferOnTail) {
            return this.graph.outEdges(this.tail, true);
        }
        const tailEdge = this.props.edgeToTail;
        return tailEdge
            ? this.graph.nonTrivialFollowupEdges(tailEdge)
            : this.graph.outEdges(this.tail);
    }
    isTerminal() {
        return this.graph.isTerminal(this.tail);
    }
    isRootPath() {
        return (0, querygraph_1.isRootVertex)(this.root);
    }
    mapMainPath(mapper) {
        const result = new Array(this.size);
        let v = this.root;
        for (let i = 0; i < this.size; i++) {
            const edge = this.edgeAt(i, v);
            result[i] = mapper(edge, i);
            if (edge) {
                v = edge.tail;
            }
        }
        return result;
    }
    edgeAt(index, v) {
        const edgeIdx = this.props.edgeIndexes[index];
        return (edgeIdx !== null ? this.graph.outEdge(v, edgeIdx) : null);
    }
    reduceMainPath(reducer, initialValue) {
        let value = initialValue;
        let v = this.root;
        for (let i = 0; i < this.size; i++) {
            const edge = this.edgeAt(i, v);
            value = reducer(value, edge, i);
            if (edge) {
                v = edge.tail;
            }
        }
        return value;
    }
    hasJustCycled() {
        if (this.root.index == this.tail.index) {
            return true;
        }
        let v = this.root;
        for (let i = 0; i < this.size - 1; i++) {
            const edge = this.edgeAt(i, v);
            if (!edge) {
                continue;
            }
            v = edge.tail;
            if (v.index == this.tail.index) {
                return true;
            }
        }
        return false;
    }
    hasAnyEdgeConditions() {
        return this.props.edgeConditions.some(c => c !== null);
    }
    isOnTopLevelQueryRoot() {
        if (!(0, querygraph_1.isRootVertex)(this.root)) {
            return false;
        }
        let vertex = this.root;
        for (let i = 0; i < this.size; i++) {
            const edge = this.edgeAt(i, vertex);
            if (!edge) {
                continue;
            }
            if (edge.transition.kind === 'FieldCollection' || !(0, federation_internals_1.isSchemaRootType)(edge.tail.type)) {
                return false;
            }
            vertex = edge.tail;
        }
        return true;
    }
    truncateTrailingDowncasts() {
        let lastNonDowncastIdx = -1;
        let v = this.root;
        let lastNonDowncastVertex = v;
        let lastNonDowncastEdge;
        let runtimeTypes = (0, querygraph_1.isFederatedGraphRootType)(this.root.type) ? [] : (0, federation_internals_1.possibleRuntimeTypes)(this.root.type);
        let runtimeTypesAtLastNonDowncastEdge = runtimeTypes;
        for (let i = 0; i < this.size; i++) {
            const edge = this.edgeAt(i, v);
            runtimeTypes = updateRuntimeTypes(runtimeTypes, edge);
            if (edge) {
                v = edge.tail;
                if (edge.transition.kind !== 'DownCast') {
                    lastNonDowncastIdx = i;
                    lastNonDowncastVertex = v;
                    lastNonDowncastEdge = edge;
                    runtimeTypesAtLastNonDowncastEdge = runtimeTypes;
                }
            }
        }
        if (lastNonDowncastIdx < 0 || lastNonDowncastIdx === this.size - 1) {
            return this;
        }
        const newSize = lastNonDowncastIdx + 1;
        return new GraphPath({
            ...this.props,
            tail: lastNonDowncastVertex,
            edgeTriggers: this.props.edgeTriggers.slice(0, newSize),
            edgeIndexes: this.props.edgeIndexes.slice(0, newSize),
            edgeConditions: this.props.edgeConditions.slice(0, newSize),
            edgeToTail: lastNonDowncastEdge,
            runtimeTypesOfTail: runtimeTypesAtLastNonDowncastEdge,
            runtimeTypesBeforeTailIfLastIsCast: undefined,
        });
    }
    markOverridding(otherOptions) {
        const newId = (0, uuid_1.v4)();
        return {
            thisPath: new GraphPath({
                ...this.props,
                ownPathIds: this.props.ownPathIds.concat(newId),
            }),
            otherOptions: otherOptions.map((paths) => paths.map((p) => new GraphPath({
                ...p.props,
                overriddingPathIds: p.props.overriddingPathIds.concat(newId),
            }))),
        };
    }
    isOverriddenBy(otherPath) {
        for (const overriddingId of this.props.overriddingPathIds) {
            if (otherPath.props.ownPathIds.includes(overriddingId)) {
                return true;
            }
        }
        return false;
    }
    tailIsInterfaceObject() {
        var _a;
        if (!(0, federation_internals_1.isObjectType)(this.tail.type)) {
            return false;
        }
        const schema = this.graph.sources.get(this.tail.source);
        const metadata = (0, federation_internals_1.federationMetadata)(schema);
        return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.isInterfaceObjectType(this.tail.type)) !== null && _a !== void 0 ? _a : false;
    }
    toString() {
        const isRoot = (0, querygraph_1.isRootVertex)(this.root);
        if (isRoot && this.size === 0) {
            return '_';
        }
        const pathStr = this.mapMainPath((edge, idx) => {
            if (edge) {
                if (isRoot && idx == 0) {
                    return edge.tail.toString();
                }
                const label = edge.label();
                return ` -${label === "" ? "" : '-[' + label + ']-'}-> ${edge.tail}`;
            }
            return ` (${this.props.edgeTriggers[idx]}) `;
        }).join('');
        const deferStr = this.deferOnTail ? ` <defer='${this.deferOnTail.label}'>` : '';
        return `${isRoot ? '' : this.root}${pathStr}${deferStr} (types: [${this.props.runtimeTypesOfTail.join(', ')}])`;
    }
}
exports.GraphPath = GraphPath;
function isRootPath(path) {
    return (0, querygraph_1.isRootVertex)(path.root);
}
exports.isRootPath = isRootPath;
function terminateWithNonRequestedTypenameField(path) {
    path = path.truncateTrailingDowncasts();
    if (!(0, federation_internals_1.isCompositeType)(path.tail.type)) {
        return path;
    }
    const typenameField = new federation_internals_1.Field(path.tail.type.typenameField());
    const edge = edgeForField(path.graph, path.tail, typenameField);
    (0, federation_internals_1.assert)(edge, () => `We should have an edge from ${path.tail} for ${typenameField}`);
    return path.add(typenameField, edge, exports.noConditionsResolution);
}
exports.terminateWithNonRequestedTypenameField = terminateWithNonRequestedTypenameField;
function traversePath(path, onEdges) {
    for (const [edge, _, conditions] of path) {
        if (conditions) {
            (0, pathTree_1.traversePathTree)(conditions, onEdges);
        }
        onEdges(edge);
    }
}
exports.traversePath = traversePath;
var UnsatisfiedConditionReason;
(function (UnsatisfiedConditionReason) {
    UnsatisfiedConditionReason[UnsatisfiedConditionReason["NO_POST_REQUIRE_KEY"] = 0] = "NO_POST_REQUIRE_KEY";
})(UnsatisfiedConditionReason = exports.UnsatisfiedConditionReason || (exports.UnsatisfiedConditionReason = {}));
exports.noConditionsResolution = { satisfied: true, cost: 0 };
exports.unsatisfiedConditionsResolution = { satisfied: false, cost: -1 };
var UnadvanceableReason;
(function (UnadvanceableReason) {
    UnadvanceableReason[UnadvanceableReason["UNSATISFIABLE_KEY_CONDITION"] = 0] = "UNSATISFIABLE_KEY_CONDITION";
    UnadvanceableReason[UnadvanceableReason["UNSATISFIABLE_REQUIRES_CONDITION"] = 1] = "UNSATISFIABLE_REQUIRES_CONDITION";
    UnadvanceableReason[UnadvanceableReason["UNRESOLVABLE_INTERFACE_OBJECT"] = 2] = "UNRESOLVABLE_INTERFACE_OBJECT";
    UnadvanceableReason[UnadvanceableReason["NO_MATCHING_TRANSITION"] = 3] = "NO_MATCHING_TRANSITION";
    UnadvanceableReason[UnadvanceableReason["UNREACHABLE_TYPE"] = 4] = "UNREACHABLE_TYPE";
    UnadvanceableReason[UnadvanceableReason["IGNORED_INDIRECT_PATH"] = 5] = "IGNORED_INDIRECT_PATH";
})(UnadvanceableReason = exports.UnadvanceableReason || (exports.UnadvanceableReason = {}));
class Unadvanceables {
    constructor(reasons) {
        this.reasons = reasons;
    }
    toString() {
        return '[' + this.reasons.map((r) => `[${r.reason}](${r.sourceSubgraph}->${r.destSubgraph}) ${r.details}`).join(', ') + ']';
    }
}
exports.Unadvanceables = Unadvanceables;
function isUnadvanceable(result) {
    return result instanceof Unadvanceables;
}
exports.isUnadvanceable = isUnadvanceable;
function pathTransitionToEdge(graph, vertex, transition) {
    for (const edge of graph.outEdges(vertex)) {
        if (edge.matchesSupergraphTransition(transition)) {
            return edge;
        }
    }
    return undefined;
}
class TransitionPathWithLazyIndirectPaths {
    constructor(path, conditionResolver) {
        this.path = path;
        this.conditionResolver = conditionResolver;
    }
    static initial(initialPath, conditionResolver) {
        return new TransitionPathWithLazyIndirectPaths(initialPath, conditionResolver);
    }
    indirectOptions() {
        if (!this.lazilyComputedIndirectPaths) {
            this.lazilyComputedIndirectPaths = this.computeIndirectPaths();
        }
        return this.lazilyComputedIndirectPaths;
    }
    computeIndirectPaths() {
        return advancePathWithNonCollectingAndTypePreservingTransitions(this.path, pathContext_1.emptyContext, this.conditionResolver, [], [], (t) => t, pathTransitionToEdge);
    }
    toString() {
        return this.path.toString();
    }
}
exports.TransitionPathWithLazyIndirectPaths = TransitionPathWithLazyIndirectPaths;
function advancePathWithTransition(subgraphPath, transition, targetType) {
    if (transition.kind === 'DownCast' && !((0, federation_internals_1.isInterfaceType)(transition.sourceType) && (0, federation_internals_1.isObjectType)(subgraphPath.path.tail.type))) {
        const supergraphRuntimeTypes = (0, federation_internals_1.possibleRuntimeTypes)(targetType);
        const subgraphRuntimeTypes = subgraphPath.path.tailPossibleRuntimeTypes();
        const intersection = supergraphRuntimeTypes.filter(t1 => subgraphRuntimeTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
        if (intersection.length === 0) {
            debug.log(() => `No intersection between casted type ${targetType} and the possible types in this subgraph`);
            return [];
        }
    }
    debug.group(() => `Trying to advance ${subgraphPath} for ${transition}`);
    debug.group('Direct options:');
    const directOptions = advancePathWithDirectTransition(subgraphPath.path, transition, subgraphPath.conditionResolver);
    let options;
    const deadEnds = [];
    if (isUnadvanceable(directOptions)) {
        options = [];
        debug.groupEnd(() => 'No direct options');
        deadEnds.push(...directOptions.reasons);
    }
    else {
        debug.groupEnd(() => advanceOptionsToString(directOptions));
        if (directOptions.length > 0 && (0, federation_internals_1.isLeafType)(targetType)) {
            debug.groupEnd(() => `reached leaf type ${targetType} so not trying indirect paths`);
            return createLazyTransitionOptions(directOptions, subgraphPath);
        }
        options = directOptions;
    }
    debug.group(`Computing indirect paths:`);
    const pathsWithNonCollecting = subgraphPath.indirectOptions();
    if (pathsWithNonCollecting.paths.length > 0) {
        debug.groupEnd(() => `${pathsWithNonCollecting.paths.length} indirect paths: ${pathsWithNonCollecting.paths}`);
        debug.group('Validating indirect options:');
        for (const nonCollectingPath of pathsWithNonCollecting.paths) {
            debug.group(() => `For indirect path ${nonCollectingPath}:`);
            const pathsWithTransition = advancePathWithDirectTransition(nonCollectingPath, transition, subgraphPath.conditionResolver);
            if (isUnadvanceable(pathsWithTransition)) {
                debug.groupEnd(() => `Cannot be advanced with ${transition}`);
                deadEnds.push(...pathsWithTransition.reasons);
            }
            else {
                debug.groupEnd(() => `Adding valid option: ${pathsWithTransition}`);
                options = options.concat(pathsWithTransition);
            }
        }
        debug.groupEnd();
    }
    else {
        debug.groupEnd('no indirect paths');
    }
    debug.groupEnd(() => options.length > 0 ? advanceOptionsToString(options) : `Cannot advance ${transition} for this path`);
    if (options.length > 0) {
        return createLazyTransitionOptions(options, subgraphPath);
    }
    const allDeadEnds = deadEnds.concat(pathsWithNonCollecting.deadEnds.reasons);
    if (transition.kind === 'FieldCollection') {
        const typeName = transition.definition.parent.name;
        const fieldName = transition.definition.name;
        const subgraphsWithDeadEnd = new Set(allDeadEnds.map(e => e.destSubgraph));
        for (const [subgraph, schema] of subgraphPath.path.graph.sources.entries()) {
            if (subgraphsWithDeadEnd.has(subgraph)) {
                continue;
            }
            const type = schema.type(typeName);
            if (type && (0, federation_internals_1.isCompositeType)(type) && type.field(fieldName)) {
                const typenameOfTail = subgraphPath.path.tail.type.name;
                const typeOfTailInSubgraph = schema.type(typenameOfTail);
                if (!typeOfTailInSubgraph) {
                    allDeadEnds.push({
                        sourceSubgraph: subgraphPath.path.tail.source,
                        destSubgraph: subgraph,
                        reason: UnadvanceableReason.UNREACHABLE_TYPE,
                        details: `cannot move to subgraph "${subgraph}", which has field "${transition.definition.coordinate}", because interface "${typenameOfTail}" is not defined in this subgraph (to jump to "${subgraph}", it would need to both define interface "${typenameOfTail}" and have a @key on it)`,
                    });
                }
                else {
                    (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(typeOfTailInSubgraph), () => `Type ${typeOfTailInSubgraph} in ${subgraph} should be composite`);
                    const metadata = (0, federation_internals_1.federationMetadata)(schema);
                    const keys = metadata ? typeOfTailInSubgraph.appliedDirectivesOf(metadata.keyDirective()) : [];
                    const allNonResolvable = keys.length > 0 && keys.every((k) => { var _a; return !((_a = k.arguments().resolvable) !== null && _a !== void 0 ? _a : true); });
                    (0, federation_internals_1.assert)(keys.length === 0 || allNonResolvable, () => `After ${subgraphPath} and for transition ${transition}, expected type ${type} in ${subgraph} to have no resolvable keys`);
                    const kindOfType = typeOfTailInSubgraph === type ? 'type' : 'interface';
                    const explanation = keys.length === 0
                        ? `${kindOfType} "${typenameOfTail}" has no @key defined in subgraph "${subgraph}"`
                        : `none of the @key defined on ${kindOfType} "${typenameOfTail}" in subgraph "${subgraph}" are resolvable (they are all declared with their "resolvable" argument set to false)`;
                    allDeadEnds.push({
                        sourceSubgraph: subgraphPath.path.tail.source,
                        destSubgraph: subgraph,
                        reason: UnadvanceableReason.UNREACHABLE_TYPE,
                        details: `cannot move to subgraph "${subgraph}", which has field "${transition.definition.coordinate}", because ${explanation}`
                    });
                }
            }
        }
    }
    return new Unadvanceables(allDeadEnds);
}
exports.advancePathWithTransition = advancePathWithTransition;
function createLazyTransitionOptions(options, origin) {
    return options.map(option => new TransitionPathWithLazyIndirectPaths(option, origin.conditionResolver));
}
function isEdgeExcluded(edge, excluded) {
    return excluded.some(([vIdx, eIdx]) => edge.head.index === vIdx && edge.index === eIdx);
}
function sameExcludedEdges(ex1, ex2) {
    if (ex1 === ex2) {
        return true;
    }
    if (ex1.length !== ex2.length) {
        return false;
    }
    for (let i = 0; i < ex1.length; ++i) {
        if (ex1[i][0] !== ex2[i][0] || ex1[i][1] !== ex2[i][1]) {
            return false;
        }
    }
    return true;
}
exports.sameExcludedEdges = sameExcludedEdges;
function addEdgeExclusion(excluded, newExclusion) {
    return excluded.concat([[newExclusion.head.index, newExclusion.index]]);
}
function isConditionExcluded(condition, excluded) {
    if (!condition) {
        return false;
    }
    return excluded.find(e => condition.equals(e)) !== undefined;
}
function addConditionExclusion(excluded, newExclusion) {
    return newExclusion ? excluded.concat(newExclusion) : excluded;
}
exports.addConditionExclusion = addConditionExclusion;
function popMin(stack) {
    let minIdx = 0;
    let minSize = stack[0].size;
    for (let i = 1; i < stack.length; i++) {
        if (stack[i].size < minSize) {
            minSize = stack[i].size;
            minIdx = i;
        }
    }
    const min = stack[minIdx];
    stack.splice(minIdx, 1);
    return min;
}
function advancePathWithNonCollectingAndTypePreservingTransitions(path, context, conditionResolver, excludedEdges, excludedConditions, convertTransitionWithCondition, triggerToEdge) {
    var _a, _b, _c;
    if (path.lastIsIntefaceObjectFakeDownCastAfterEnteringSubgraph()) {
        const reachableSubgraphs = new Set(path.nextEdges().filter((e) => !e.transition.collectOperationElements && e.tail.source !== path.tail.source).map((e) => e.tail.source));
        return {
            paths: [],
            deadEnds: new Unadvanceables(Array.from(reachableSubgraphs).map((s) => ({
                sourceSubgraph: path.tail.source,
                destSubgraph: s,
                reason: UnadvanceableReason.IGNORED_INDIRECT_PATH,
                details: `ignoring moving from "${path.tail.source}" to "${s}" as a more direct option exists`,
            }))),
        };
    }
    const isTopLevelPath = path.isOnTopLevelQueryRoot();
    const typeName = (0, querygraph_1.isFederatedGraphRootType)(path.tail.type) ? undefined : path.tail.type.name;
    const originalSource = path.tail.source;
    const bestPathBySource = new Map();
    const deadEnds = [];
    const toTry = [path];
    while (toTry.length > 0) {
        const toAdvance = popMin(toTry);
        const nextEdges = toAdvance.nextEdges().filter(e => !e.transition.collectOperationElements);
        if (nextEdges.length === 0) {
            const outEdges = toAdvance.graph.outEdges(toAdvance.tail).filter(e => !e.transition.collectOperationElements);
            if (outEdges.length > 0) {
                debug.log(() => `Nothing to try for ${toAdvance}: it only has "trivial" non-collecting outbound edges`);
                for (const edge of outEdges) {
                    if (edge.tail.source !== toAdvance.tail.source && edge.tail.source !== originalSource) {
                        deadEnds.push({
                            sourceSubgraph: toAdvance.tail.source,
                            destSubgraph: edge.tail.source,
                            reason: UnadvanceableReason.IGNORED_INDIRECT_PATH,
                            details: `ignoring moving to subgraph "${edge.tail.source}" using @key(fields: "${(_a = edge.conditions) === null || _a === void 0 ? void 0 : _a.toString(true, false)}") of "${edge.head.type}" because there is a more direct path in ${edge.tail.source} that avoids ${toAdvance.tail.source} altogether`
                        });
                    }
                }
            }
            else {
                debug.log(() => `Nothing to try for ${toAdvance}: it has no non-collecting outbound edges`);
            }
            continue;
        }
        debug.group(() => `From ${toAdvance}:`);
        for (const edge of nextEdges) {
            debug.group(() => `Testing edge ${edge}`);
            if (isEdgeExcluded(edge, excludedEdges)) {
                debug.groupEnd(`Ignored: edge is excluded`);
                continue;
            }
            const target = edge.tail;
            if (target.source === originalSource && !toAdvance.deferOnTail) {
                debug.groupEnd('Ignored: edge get us back to our original source');
                continue;
            }
            if (isTopLevelPath && edge.transition.kind === 'RootTypeResolution' && !(toAdvance.deferOnTail && edge.isKeyOrRootTypeEdgeToSelf())) {
                debug.groupEnd(`Ignored: edge is a top-level "RootTypeResolution"`);
                continue;
            }
            const prevForSource = bestPathBySource.get(target.source);
            if (prevForSource === null) {
                debug.groupEnd(() => `Ignored: we've shown before than going to ${target.source} is not productive`);
                continue;
            }
            if (prevForSource
                && (prevForSource[0].size < toAdvance.size + 1
                    || (prevForSource[0].size == toAdvance.size + 1 && prevForSource[1] <= 1))) {
                debug.groupEnd(() => `Ignored: a better (shorter) path to the same subgraph already added`);
                continue;
            }
            if (isConditionExcluded(edge.conditions, excludedConditions)) {
                debug.groupEnd(`Ignored: edge condition is excluded`);
                continue;
            }
            debug.group(() => `Validating conditions ${edge.conditions}`);
            const conditionResolution = canSatisfyConditions(toAdvance, edge, conditionResolver, context, addEdgeExclusion(excludedEdges, edge), excludedConditions);
            if (conditionResolution.satisfied) {
                debug.groupEnd('Condition satisfied');
                if (prevForSource && prevForSource[0].size === toAdvance.size + 1 && prevForSource[1] <= conditionResolution.cost) {
                    debug.groupEnd('Ignored: a better (less costly) path to the same subgraph already added');
                    continue;
                }
                const subgraphEnteringEdge = toAdvance.subgraphEnteringEdge;
                if (subgraphEnteringEdge && edge.transition.kind === 'KeyResolution' && subgraphEnteringEdge.edge.tail.type.name !== typeName) {
                    const prevSubgraphVertex = toAdvance.checkDirectPathFromPreviousSubgraphTo(edge.tail.type.name, triggerToEdge);
                    const backToPreviousSubgraph = subgraphEnteringEdge.edge.head.source === edge.tail.source;
                    const maxCost = toAdvance.subgraphEnteringEdge.cost + (backToPreviousSubgraph ? 0 : conditionResolution.cost);
                    if (prevSubgraphVertex
                        && (backToPreviousSubgraph
                            || hasValidDirectKeyEdge(toAdvance.graph, prevSubgraphVertex, edge.tail.source, conditionResolver, maxCost) != undefined)) {
                        debug.groupEnd(() => `Ignored: edge correspond to a detour by subgraph ${edge.head.source} from subgraph ${subgraphEnteringEdge.edge.head.source}: `
                            + `we have a direct path from ${subgraphEnteringEdge.edge.head.type} to ${edge.tail.type} in ${subgraphEnteringEdge.edge.head.source}`
                            + (backToPreviousSubgraph ? '.' : ` and can move to ${edge.tail.source} from there`));
                        bestPathBySource.set(edge.tail.source, null);
                        deadEnds.push({
                            sourceSubgraph: toAdvance.tail.source,
                            destSubgraph: edge.tail.source,
                            reason: UnadvanceableReason.IGNORED_INDIRECT_PATH,
                            details: `ignoring moving to subgraph "${edge.tail.source}" using @key(fields: "${(_b = edge.conditions) === null || _b === void 0 ? void 0 : _b.toString(true, false)}") of "${edge.head.type}" because there is a more direct path in ${edge.tail.source} that avoids ${toAdvance.tail.source} altogether`
                        });
                        continue;
                    }
                }
                const updatedPath = toAdvance.add(convertTransitionWithCondition(edge.transition, context), edge, conditionResolution);
                debug.log(() => `Using edge, advance path: ${updatedPath}`);
                bestPathBySource.set(target.source, [updatedPath, conditionResolution.cost]);
                if (edge.transition.kind === 'KeyResolution' && edge.head.source !== edge.tail.source) {
                    toTry.push(updatedPath);
                }
            }
            else {
                debug.groupEnd('Condition unsatisfiable');
                const source = toAdvance.tail.source;
                const dest = edge.tail.source;
                const hasOverriddenField = conditionHasOverriddenFieldsInSource(path.graph.sources.get(toAdvance.tail.source), edge.conditions);
                const extraMsg = hasOverriddenField
                    ? ` (note that some of those key fields are overridden in "${source}")`
                    : "";
                deadEnds.push({
                    sourceSubgraph: source,
                    destSubgraph: dest,
                    reason: UnadvanceableReason.UNSATISFIABLE_KEY_CONDITION,
                    details: `cannot move to subgraph "${dest}" using @key(fields: "${(_c = edge.conditions) === null || _c === void 0 ? void 0 : _c.toString(true, false)}") of "${edge.head.type}", the key field(s) cannot be resolved from subgraph "${source}"${extraMsg}`
                });
            }
            debug.groupEnd();
        }
        debug.groupEnd();
    }
    return {
        paths: (0, federation_internals_1.mapValues)(bestPathBySource).filter(p => p !== null).map(b => b[0]),
        deadEnds: new Unadvanceables(deadEnds)
    };
}
function conditionHasOverriddenFieldsInSource(schema, condition) {
    const externalDirective = (0, federation_internals_1.federationMetadata)(schema).externalDirective();
    return (0, federation_internals_1.allFieldDefinitionsInSelectionSet)(condition).some((field) => {
        var _a, _b;
        const typeInSource = schema.type(field.parent.name);
        const fieldInSource = typeInSource && (0, federation_internals_1.isObjectType)(typeInSource) && typeInSource.field(field.name);
        return fieldInSource && ((_b = (_a = fieldInSource.appliedDirectivesOf(externalDirective)) === null || _a === void 0 ? void 0 : _a.pop()) === null || _b === void 0 ? void 0 : _b.arguments().reason) === '[overridden]';
    });
}
function hasValidDirectKeyEdge(graph, from, to, conditionResolver, maxCost) {
    for (const edge of graph.outEdges(from)) {
        if (edge.transition.kind !== 'KeyResolution' || edge.tail.source !== to) {
            continue;
        }
        const resolution = conditionResolver(edge, pathContext_1.emptyContext, [], []);
        if (!resolution.satisfied) {
            continue;
        }
        if (resolution.cost <= maxCost) {
            return true;
        }
    }
    return false;
}
function advancePathWithDirectTransition(path, transition, conditionResolver) {
    (0, federation_internals_1.assert)(transition.collectOperationElements, "Supergraphs shouldn't have transitions that don't collect elements");
    if (transition.kind === 'FieldCollection'
        && transition.definition.parent.name !== path.tail.type.name
        && (0, federation_internals_1.isCompositeType)(path.tail.type)
        && !path.tailIsInterfaceObject()) {
        const updatedPath = advancePathWithDirectTransition(path, new transition_1.DownCast(path.tail.type, transition.definition.parent), conditionResolver);
        (0, federation_internals_1.assert)(!isUnadvanceable(updatedPath), () => `Advancing ${path} for ${transition} gave ${updatedPath}`);
        (0, federation_internals_1.assert)(updatedPath.length === 1, () => `Expect one path, got ${updatedPath.length}`);
        path = updatedPath[0];
    }
    const options = [];
    const deadEnds = [];
    for (const edge of path.nextEdges()) {
        if (!edge.matchesSupergraphTransition(transition)) {
            continue;
        }
        const conditionResolution = canSatisfyConditions(path, edge, conditionResolver, pathContext_1.emptyContext, [], []);
        if (conditionResolution.satisfied) {
            options.push(path.add(transition, edge, conditionResolution));
        }
        else {
            switch (edge.transition.kind) {
                case 'FieldCollection':
                    {
                        const field = edge.transition.definition;
                        const parentTypeInSubgraph = path.graph.sources.get(edge.head.source).type(field.parent.name);
                        const details = conditionResolution.unsatisfiedConditionReason === UnsatisfiedConditionReason.NO_POST_REQUIRE_KEY
                            ? `@require condition on field "${field.coordinate}" can be satisfied but missing usable key on "${parentTypeInSubgraph}" in subgraph "${edge.head.source}" to resume query`
                            : `cannot satisfy @require conditions on field "${field.coordinate}"${warnOnKeyFieldsMarkedExternal(parentTypeInSubgraph)}`;
                        deadEnds.push({
                            sourceSubgraph: edge.head.source,
                            destSubgraph: edge.head.source,
                            reason: UnadvanceableReason.UNSATISFIABLE_REQUIRES_CONDITION,
                            details
                        });
                    }
                    break;
                case 'InterfaceObjectFakeDownCast':
                    {
                        const details = conditionResolution.unsatisfiedConditionReason === UnsatisfiedConditionReason.NO_POST_REQUIRE_KEY
                            ? `@interfaceObject type "${edge.transition.sourceType.coordinate}" misses a resolvable key to resume query once the implementation type has been resolved`
                            : `no subgraph can be reached to resolve the implementation type of @interfaceObject type "${edge.transition.sourceType.coordinate}"`;
                        deadEnds.push({
                            sourceSubgraph: edge.head.source,
                            destSubgraph: edge.head.source,
                            reason: UnadvanceableReason.UNRESOLVABLE_INTERFACE_OBJECT,
                            details
                        });
                    }
                    break;
                default:
                    (0, federation_internals_1.assert)(false, () => `Shouldn't have conditions on direct transition ${transition}`);
            }
        }
    }
    if (options.length > 0) {
        return options;
    }
    else if (deadEnds.length > 0) {
        return new Unadvanceables(deadEnds);
    }
    else {
        let details;
        const subgraph = path.tail.source;
        if (transition.kind === 'FieldCollection') {
            const schema = path.graph.sources.get(subgraph);
            const fieldTypeName = transition.definition.parent.name;
            const typeInSubgraph = schema.type(fieldTypeName);
            if (!typeInSubgraph && path.tail.type.name !== fieldTypeName) {
                details = `cannot find implementation type "${fieldTypeName}" (supergraph interface "${path.tail.type.name}" is declared with @interfaceObject in "${subgraph}")`;
            }
            else {
                const fieldInSubgraph = typeInSubgraph && (0, federation_internals_1.isCompositeType)(typeInSubgraph)
                    ? typeInSubgraph.field(transition.definition.name)
                    : undefined;
                if (fieldInSubgraph) {
                    const externalDirective = fieldInSubgraph.appliedDirectivesOf((0, federation_internals_1.federationMetadata)(fieldInSubgraph.schema()).externalDirective()).pop();
                    (0, federation_internals_1.assert)(externalDirective, () => `${fieldInSubgraph.coordinate} in ${subgraph} is not external but there is no corresponding edge (edges from ${path} = [${path.nextEdges().join(', ')}])`);
                    const overriddingSources = externalDirective.arguments().reason === '[overridden]'
                        ? findOverriddingSourcesIfOverridden(fieldInSubgraph, subgraph, path.graph.sources)
                        : [];
                    if (overriddingSources.length > 0) {
                        details = `field "${transition.definition.coordinate}" is not resolvable because it is overridden by ${(0, federation_internals_1.printSubgraphNames)(overriddingSources)}`;
                    }
                    else {
                        details = `field "${transition.definition.coordinate}" is not resolvable because marked @external`;
                    }
                }
                else {
                    details = `cannot find field "${transition.definition.coordinate}"`;
                }
            }
        }
        else {
            (0, federation_internals_1.assert)(transition.kind === 'DownCast', () => `Unhandled direct transition ${transition} of kind ${transition.kind}`);
            details = `cannot find type "${transition.castedType}"`;
        }
        return new Unadvanceables([{
                sourceSubgraph: subgraph,
                destSubgraph: subgraph,
                reason: UnadvanceableReason.NO_MATCHING_TRANSITION,
                details
            }]);
    }
}
function findOverriddingSourcesIfOverridden(field, fieldSource, sources) {
    return [...sources.entries()]
        .map(([name, schema]) => {
        var _a, _b, _c;
        if (name === querygraph_1.FEDERATED_GRAPH_ROOT_SOURCE || name === fieldSource) {
            return undefined;
        }
        const sourceMetadata = (0, federation_internals_1.federationMetadata)(schema);
        const typeInSource = schema.type(field.parent.name);
        if (!typeInSource || !(0, federation_internals_1.isObjectType)(typeInSource)) {
            return undefined;
        }
        const fieldInSource = typeInSource.field(field.name);
        const isOverriddingSource = ((_c = (_b = (_a = fieldInSource === null || fieldInSource === void 0 ? void 0 : fieldInSource.appliedDirectivesOf(sourceMetadata.overrideDirective())) === null || _a === void 0 ? void 0 : _a.pop()) === null || _b === void 0 ? void 0 : _b.arguments()) === null || _c === void 0 ? void 0 : _c.from) === fieldSource;
        return isOverriddingSource ? name : undefined;
    })
        .filter((name) => !!name);
}
function warnOnKeyFieldsMarkedExternal(type) {
    const metadata = (0, federation_internals_1.federationMetadata)(type.schema());
    (0, federation_internals_1.assert)(metadata, "Type should originate from a federation subgraph schema");
    const keyDirective = metadata.keyDirective();
    const keys = type.appliedDirectivesOf(keyDirective);
    if (keys.length === 0) {
        return "";
    }
    const keyFieldMarkedExternal = [];
    for (const key of keys) {
        const fieldSet = (0, federation_internals_1.parseFieldSetArgument)({ parentType: type, directive: key });
        for (const selection of fieldSet.selections()) {
            if (selection.kind === 'FieldSelection' && selection.element.definition.hasAppliedDirective(metadata.externalDirective())) {
                const fieldName = selection.element.name;
                if (!keyFieldMarkedExternal.includes(fieldName)) {
                    keyFieldMarkedExternal.push(fieldName);
                }
            }
        }
    }
    if (keyFieldMarkedExternal.length === 0) {
        return "";
    }
    const printedFields = keyFieldMarkedExternal.map(f => `"${f}"`).join(', ');
    const fieldWithPlural = keyFieldMarkedExternal.length === 1 ? 'field' : 'fields';
    return ` (please ensure that this is not due to key ${fieldWithPlural} ${printedFields} being accidentally marked @external)`;
}
function getLocallySatisfiableKey(graph, typeVertex) {
    const type = typeVertex.type;
    const schema = graph.sources.get(typeVertex.source);
    const metadata = schema ? (0, federation_internals_1.federationMetadata)(schema) : undefined;
    (0, federation_internals_1.assert)(metadata, () => `Could not find federation metadata for source ${typeVertex.source}`);
    const keyDirective = metadata.keyDirective();
    for (const key of type.appliedDirectivesOf(keyDirective)) {
        const selection = (0, federation_internals_1.parseFieldSetArgument)({ parentType: type, directive: key });
        if (!metadata.selectionSelectsAnyExternalField(selection)) {
            return selection;
        }
    }
    return undefined;
}
exports.getLocallySatisfiableKey = getLocallySatisfiableKey;
function canSatisfyConditions(path, edge, conditionResolver, context, excludedEdges, excludedConditions) {
    const conditions = edge.conditions;
    if (!conditions) {
        return exports.noConditionsResolution;
    }
    debug.group(() => `Checking conditions ${conditions} on edge ${edge}`);
    const resolution = conditionResolver(edge, context, excludedEdges, excludedConditions);
    if (!resolution.satisfied) {
        debug.groupEnd('Conditions are not satisfied');
        return exports.unsatisfiedConditionsResolution;
    }
    const pathTree = resolution.pathTree;
    const lastEdge = path.lastEdge();
    if (edge.transition.kind === 'FieldCollection'
        && lastEdge !== null
        && (lastEdge === null || lastEdge === void 0 ? void 0 : lastEdge.transition.kind) !== 'KeyResolution'
        && (!pathTree || pathTree.isAllInSameSubgraph())) {
        debug.log('@requires conditions are satisfied, but validating post-require key.');
        const postRequireKeyCondition = getLocallySatisfiableKey(path.graph, edge.head);
        if (!postRequireKeyCondition) {
            debug.groupEnd('Post-require conditions cannot be satisfied');
            return { ...exports.unsatisfiedConditionsResolution, unsatisfiedConditionReason: UnsatisfiedConditionReason.NO_POST_REQUIRE_KEY };
        }
    }
    debug.groupEnd('Conditions satisfied');
    return resolution;
}
function isTerminalOperation(operation) {
    return operation.kind === 'Field' && (0, federation_internals_1.isLeafType)((0, federation_internals_1.baseType)(operation.definition.type));
}
class SimultaneousPathsWithLazyIndirectPaths {
    constructor(paths, context, conditionResolver, excludedNonCollectingEdges = [], excludedConditionsOnNonCollectingEdges = []) {
        this.paths = paths;
        this.context = context;
        this.conditionResolver = conditionResolver;
        this.excludedNonCollectingEdges = excludedNonCollectingEdges;
        this.excludedConditionsOnNonCollectingEdges = excludedConditionsOnNonCollectingEdges;
        this.lazilyComputedIndirectPaths = new Array(paths.length);
    }
    indirectOptions(updatedContext, pathIdx) {
        if (updatedContext !== this.context) {
            return this.computeIndirectPaths(pathIdx);
        }
        if (!this.lazilyComputedIndirectPaths[pathIdx]) {
            this.lazilyComputedIndirectPaths[pathIdx] = this.computeIndirectPaths(pathIdx);
        }
        return this.lazilyComputedIndirectPaths[pathIdx];
    }
    computeIndirectPaths(idx) {
        return advancePathWithNonCollectingAndTypePreservingTransitions(this.paths[idx], this.context, this.conditionResolver, this.excludedNonCollectingEdges, this.excludedConditionsOnNonCollectingEdges, (_t, context) => context, opPathTriggerToEdge);
    }
    toString() {
        return simultaneousPathsToString(this.paths);
    }
}
exports.SimultaneousPathsWithLazyIndirectPaths = SimultaneousPathsWithLazyIndirectPaths;
function simultaneousPathsToString(simultaneousPaths, indentOnNewLine = "") {
    const paths = Array.isArray(simultaneousPaths) ? simultaneousPaths : simultaneousPaths.paths;
    if (paths.length === 0) {
        return '<no path>';
    }
    if (paths.length === 1) {
        return paths[0].toString();
    }
    return `{\n${indentOnNewLine}  ` + paths.join(`\n${indentOnNewLine}  `) + `\n${indentOnNewLine}}`;
}
exports.simultaneousPathsToString = simultaneousPathsToString;
function advanceOptionsToString(options) {
    if (!options) {
        return '<no options>';
    }
    if (options.length === 0) {
        return '<unsatisfiable branch>';
    }
    if (options.length === 1) {
        return '[' + options[0] + ']';
    }
    return '[\n  ' + options.map(opt => Array.isArray(opt) ? simultaneousPathsToString(opt, "  ") : opt.toString()).join('\n  ') + '\n]';
}
exports.advanceOptionsToString = advanceOptionsToString;
function advanceSimultaneousPathsWithOperation(supergraphSchema, subgraphSimultaneousPaths, operation) {
    debug.group(() => `Trying to advance ${simultaneousPathsToString(subgraphSimultaneousPaths)} for ${operation}`);
    const updatedContext = subgraphSimultaneousPaths.context.withContextOf(operation);
    const optionsForEachPath = [];
    for (const [i, path] of subgraphSimultaneousPaths.paths.entries()) {
        let options = undefined;
        debug.group(() => `Computing options for ${path}`);
        const shouldReenterSubgraph = path.deferOnTail && operation.kind === 'Field';
        if (!shouldReenterSubgraph) {
            debug.group(() => `Direct options`);
            const { options: advanceOptions, hasOnlyTypeExplodedResults } = advanceWithOperation(supergraphSchema, path, operation, updatedContext, subgraphSimultaneousPaths.conditionResolver);
            options = advanceOptions;
            debug.groupEnd(() => advanceOptionsToString(options));
            if (options && (options.length === 0 || (isTerminalOperation(operation) && !hasOnlyTypeExplodedResults) || operation.kind === 'FragmentElement')) {
                debug.groupEnd(() => `Final options for ${path}: ${advanceOptionsToString(options)}`);
                if (options.length > 0) {
                    optionsForEachPath.push(options);
                }
                continue;
            }
        }
        options = options !== null && options !== void 0 ? options : [];
        if (operation.kind === 'Field') {
            debug.group(`Computing indirect paths:`);
            const pathsWithNonCollecting = subgraphSimultaneousPaths.indirectOptions(updatedContext, i);
            debug.groupEnd(() => pathsWithNonCollecting.paths.length == 0 ? `no indirect paths` : `${pathsWithNonCollecting.paths.length} indirect paths`);
            if (pathsWithNonCollecting.paths.length > 0) {
                debug.group('Validating indirect options:');
                for (const pathWithNonCollecting of pathsWithNonCollecting.paths) {
                    debug.group(() => `For indirect path ${pathWithNonCollecting}:`);
                    const { options: pathWithOperation } = advanceWithOperation(supergraphSchema, pathWithNonCollecting, operation, updatedContext, subgraphSimultaneousPaths.conditionResolver);
                    if (!pathWithOperation) {
                        debug.groupEnd(() => `Ignoring: cannot be advanced with ${operation}`);
                        continue;
                    }
                    debug.groupEnd(() => `Adding valid option: ${pathWithOperation}`);
                    (0, federation_internals_1.assert)(pathWithOperation.length > 0, () => `Unexpected empty options after non-collecting path ${pathWithNonCollecting} for ${operation}`);
                    options = options.concat(pathWithOperation);
                }
                debug.groupEnd();
            }
        }
        if (options.length === 0 && shouldReenterSubgraph) {
            debug.group(() => `Cannot defer (no indirect options); falling back to direct options`);
            const { options: advanceOptions } = advanceWithOperation(supergraphSchema, path, operation, updatedContext, subgraphSimultaneousPaths.conditionResolver);
            options = advanceOptions !== null && advanceOptions !== void 0 ? advanceOptions : [];
            debug.groupEnd(() => advanceOptionsToString(options));
        }
        if (options.length === 0) {
            debug.groupEnd();
            debug.groupEnd(() => `No valid options for ${operation}, aborting operation ${operation}`);
            return undefined;
        }
        else {
            debug.groupEnd(() => advanceOptionsToString(options));
            optionsForEachPath.push(options);
        }
    }
    const allOptions = flatCartesianProduct(optionsForEachPath);
    debug.groupEnd(() => advanceOptionsToString(allOptions));
    return createLazyOptions(allOptions, subgraphSimultaneousPaths, updatedContext);
}
exports.advanceSimultaneousPathsWithOperation = advanceSimultaneousPathsWithOperation;
function createInitialOptions(initialPath, initialContext, conditionResolver, excludedEdges, excludedConditions) {
    const lazyInitialPath = new SimultaneousPathsWithLazyIndirectPaths([initialPath], initialContext, conditionResolver, excludedEdges, excludedConditions);
    if ((0, querygraph_1.isFederatedGraphRootType)(initialPath.tail.type)) {
        const initialOptions = lazyInitialPath.indirectOptions(initialContext, 0);
        return createLazyOptions(initialOptions.paths.map(p => [p]), lazyInitialPath, initialContext);
    }
    else {
        return [lazyInitialPath];
    }
}
exports.createInitialOptions = createInitialOptions;
function createLazyOptions(options, origin, context) {
    return options.map(option => new SimultaneousPathsWithLazyIndirectPaths(option, context, origin.conditionResolver, origin.excludedNonCollectingEdges, origin.excludedConditionsOnNonCollectingEdges));
}
function opPathTriggerToEdge(graph, vertex, trigger) {
    if (trigger instanceof pathContext_1.PathContext) {
        return undefined;
    }
    if (trigger.kind === 'Field') {
        return edgeForField(graph, vertex, trigger);
    }
    else {
        return trigger.typeCondition ? edgeForTypeCast(graph, vertex, trigger.typeCondition.name) : null;
    }
}
function flatCartesianProduct(arr) {
    const size = arr.length;
    if (size === 0) {
        return [];
    }
    const eltIndexes = new Array(size);
    let totalCombinations = 1;
    for (let i = 0; i < size; ++i) {
        const eltSize = arr[i].length;
        if (!eltSize) {
            totalCombinations = 0;
            break;
        }
        eltIndexes[i] = 0;
        totalCombinations *= eltSize;
    }
    const product = new Array(totalCombinations);
    for (let i = 0; i < totalCombinations; ++i) {
        let itemSize = 0;
        for (let j = 0; j < size; ++j) {
            itemSize += arr[j][eltIndexes[j]].length;
        }
        const item = new Array(itemSize);
        let k = 0;
        for (let j = 0; j < size; ++j) {
            for (const v of arr[j][eltIndexes[j]]) {
                item[k++] = v;
            }
        }
        product[i] = item;
        for (let idx = 0; idx < size; ++idx) {
            if (eltIndexes[idx] == arr[idx].length - 1) {
                eltIndexes[idx] = 0;
            }
            else {
                eltIndexes[idx] += 1;
                break;
            }
        }
    }
    return product;
}
function anImplementationHasAProvides(fieldName, itf) {
    const metadata = (0, federation_internals_1.federationMetadata)(itf.schema());
    (0, federation_internals_1.assert)(metadata, "Interface should have come from a federation subgraph");
    for (const implem of itf.possibleRuntimeTypes()) {
        const field = implem.field(fieldName);
        if (field && field.hasAppliedDirective(metadata.providesDirective())) {
            return true;
        }
    }
    return false;
}
function anImplementationIsEntityWithFieldShareable(path, fieldName, itf) {
    const metadata = (0, federation_internals_1.federationMetadata)(itf.schema());
    (0, federation_internals_1.assert)(metadata, "Interface should have come from a federation subgraph");
    for (const implem of itf.possibleRuntimeTypes()) {
        if (!implem.hasAppliedDirective(metadata.keyDirective())) {
            continue;
        }
        const field = implem.field(fieldName);
        if (!field || !field.hasAppliedDirective(metadata.shareableDirective())) {
            continue;
        }
        const type = (0, federation_internals_1.baseType)(field.type);
        if ((0, federation_internals_1.isLeafType)(type)) {
            continue;
        }
        if ((0, federation_internals_1.isObjectType)(type) && type.fields().every((f) => (0, federation_internals_1.isLeafType)((0, federation_internals_1.baseType)(f.type)))) {
            const fieldNames = new Set(type.fields().map((f) => f.name));
            for (const v of path.graph.verticesForType(implem.name)) {
                if (v.source === path.tail.source) {
                    continue;
                }
                const otherMetadata = (0, federation_internals_1.federationMetadata)(v.type.schema());
                (0, federation_internals_1.assert)(otherMetadata, "Type should have come from a federation subgraph");
                (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(v.type) || (0, federation_internals_1.isInterfaceType)(v.type), () => `${implem} is an object in ${path.tail.source} but a ${v.type.kind} in ${v.source}`);
                const fieldInOther = v.type.field(fieldName);
                if (!fieldInOther || !fieldInOther.hasAppliedDirective(otherMetadata.shareableDirective())) {
                    continue;
                }
                const typeInOther = (0, federation_internals_1.baseType)(fieldInOther.type);
                if (typeInOther.name !== type.name || !((0, federation_internals_1.isObjectType)(typeInOther) || (0, federation_internals_1.isInterfaceType)(typeInOther))) {
                    return true;
                }
                const otherNames = new Set(typeInOther.fields().map((f) => f.name));
                if (!(0, federation_internals_1.isSubset)(fieldNames, otherNames)) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    return false;
}
function isProvidedEdge(edge) {
    return edge.transition.kind === 'FieldCollection' && edge.transition.isPartOfProvide;
}
function advanceWithOperation(supergraphSchema, path, operation, context, conditionResolver) {
    debug.group(() => `Trying to advance ${path} directly with ${operation}`);
    const currentType = path.tail.type;
    if ((0, querygraph_1.isFederatedGraphRootType)(currentType)) {
        debug.groupEnd('Cannot advance federated graph root with direct operations');
        return { options: undefined };
    }
    if (operation.kind === 'Field') {
        const field = operation.definition;
        switch (currentType.kind) {
            case 'ObjectType':
                const edge = nextEdgeForField(path, operation);
                if (!edge) {
                    debug.groupEnd(() => `No edge for field ${field} on object type ${currentType}`);
                    return { options: undefined };
                }
                if (path.tailIsInterfaceObject() && field.parent.name !== currentType.name) {
                    const fieldOnCurrentType = currentType.field(field.name);
                    (0, federation_internals_1.assert)(fieldOnCurrentType, () => `We should not have found edge ${edge} for ${field} from ${path}`);
                    operation = operation.withUpdatedDefinition(fieldOnCurrentType);
                }
                const fieldPath = addFieldEdge(path, operation, edge, conditionResolver, context);
                debug.groupEnd(() => fieldPath
                    ? `Collected field ${field} on object type ${currentType}`
                    : `Cannot satisfy @requires on field ${field} for object type ${currentType}`);
                return { options: pathAsOptions(fieldPath) };
            case 'InterfaceType':
                const fieldIsOfAnImplementation = field.parent.name !== currentType.name;
                const itfEdge = fieldIsOfAnImplementation ? undefined : nextEdgeForField(path, operation);
                let itfPath = undefined;
                let directPathOverrideTypeExplosion = false;
                if (itfEdge) {
                    itfPath = addFieldEdge(path, operation, itfEdge, conditionResolver, context);
                    (0, federation_internals_1.assert)(itfPath, () => `Interface edge ${itfEdge} shouldn't have conditions`);
                    directPathOverrideTypeExplosion =
                        field.name === federation_internals_1.typenameFieldName
                            || (!isProvidedEdge(itfEdge) && !anImplementationHasAProvides(field.name, currentType));
                    if (directPathOverrideTypeExplosion && ((0, federation_internals_1.isLeafType)(field.type) || !anImplementationIsEntityWithFieldShareable(path, field.name, currentType))) {
                        debug.groupEnd(() => `Collecting (leaf) field ${field} on interface ${currentType} without type-exploding`);
                        return { options: pathAsOptions(itfPath) };
                    }
                    debug.log(() => `Collecting field ${field} on interface ${currentType} as 1st option`);
                }
                let implementations;
                if (fieldIsOfAnImplementation) {
                    (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(field.parent) && path.tailPossibleRuntimeTypes().some((t) => t.name === field.parent.name), () => `${field.coordinate} requested on ${currentType}, but ${field.parent} is not an implementation`);
                    implementations = [field.parent];
                    debug.log(() => `Casting into requested type ${field.parent}`);
                }
                else {
                    implementations = path.tailPossibleRuntimeTypes();
                    debug.log(() => !itfPath
                        ? `No direct edge: type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}]`
                        : `Type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}] as 2nd option`);
                }
                const optionsByImplems = [];
                for (const implemType of implementations) {
                    const castOp = new federation_internals_1.FragmentElement(currentType, implemType.name);
                    debug.group(() => `Handling implementation ${implemType}`);
                    const implemOptions = advanceSimultaneousPathsWithOperation(supergraphSchema, new SimultaneousPathsWithLazyIndirectPaths([path], context, conditionResolver), castOp);
                    if (!implemOptions) {
                        debug.groupEnd();
                        debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options [${itfPath}]`);
                        return { options: pathAsOptions(itfPath) };
                    }
                    if (implemOptions.length === 0) {
                        debug.groupEnd(() => `Cannot ever get ${implemType} from this branch, ignoring it`);
                        continue;
                    }
                    let withField = [];
                    debug.log(() => `Trying to collect ${field} from options ${advanceOptionsToString(implemOptions)}`);
                    for (const optPaths of implemOptions) {
                        debug.group(() => `For ${simultaneousPathsToString(optPaths)}`);
                        const withFieldOptions = advanceSimultaneousPathsWithOperation(supergraphSchema, optPaths, operation);
                        if (!withFieldOptions) {
                            debug.groupEnd(() => `Cannot collect ${field}`);
                            continue;
                        }
                        (0, federation_internals_1.assert)(withFieldOptions.length > 0, () => `Unexpected unsatisfiable path after ${optPaths} for ${operation}`);
                        debug.groupEnd(() => `Collected field ${field}: adding ${advanceOptionsToString(withFieldOptions)}`);
                        withField = withField.concat(withFieldOptions.map(opt => opt.paths));
                    }
                    if (withField.length === 0) {
                        debug.groupEnd();
                        debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options [${itfPath}]`);
                        return { options: pathAsOptions(itfPath) };
                    }
                    debug.groupEnd(() => `Collected field ${field} from ${implemType}`);
                    optionsByImplems.push(withField);
                }
                let allOptions = flatCartesianProduct(optionsByImplems);
                if (itfPath) {
                    if (directPathOverrideTypeExplosion) {
                        ({ thisPath: itfPath, otherOptions: allOptions } = itfPath.markOverridding(allOptions));
                    }
                    allOptions = pathAsOptions(itfPath).concat(allOptions);
                }
                debug.groupEnd(() => `With type-exploded options: ${advanceOptionsToString(allOptions)}`);
                return { options: allOptions, hasOnlyTypeExplodedResults: !itfPath };
            case 'UnionType':
                (0, federation_internals_1.assert)(field.name === federation_internals_1.typenameFieldName, () => `Invalid field selection ${operation} for union type ${currentType}`);
                const typenameEdge = nextEdgeForField(path, operation);
                (0, federation_internals_1.assert)(typenameEdge, `Should always have an edge for __typename edge on an union`);
                debug.groupEnd(() => `Trivial collection of __typename for union ${currentType}`);
                return { options: pathAsOptions(addFieldEdge(path, operation, typenameEdge, conditionResolver, context)) };
            default:
                (0, federation_internals_1.assert)(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
        }
    }
    else {
        (0, federation_internals_1.assert)(operation.kind === 'FragmentElement', () => "Unhandled operation kind: " + operation.kind);
        if (!operation.typeCondition || currentType.name === operation.typeCondition.name) {
            debug.groupEnd(() => `No edge to take for condition ${operation} from current type ${currentType}`);
            const updatedPath = operation.appliedDirectives.length > 0
                ? path.add(operation, null, exports.noConditionsResolution, operation.deferDirectiveArgs())
                : path;
            return { options: [[updatedPath]] };
        }
        const typeName = operation.typeCondition.name;
        switch (currentType.kind) {
            case 'InterfaceType':
            case 'UnionType':
                const edge = nextEdgeForTypeCast(path, typeName);
                if (edge) {
                    (0, federation_internals_1.assert)(!edge.conditions, "TypeCast collecting edges shouldn't have conditions");
                    debug.groupEnd(() => `Using type-casting edge for ${typeName} from current type ${currentType}`);
                    return { options: [[path.add(operation, edge, exports.noConditionsResolution, operation.deferDirectiveArgs())]] };
                }
                const parentTypes = path.tailPossibleRuntimeTypes();
                const castedTypes = (0, federation_internals_1.possibleRuntimeTypes)(supergraphSchema.type(typeName));
                const intersection = parentTypes.filter(t1 => castedTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
                debug.log(() => `Trying to type-explode into intersection between ${currentType} and ${typeName} = [${intersection}]`);
                const optionsByImplems = [];
                for (const tName of intersection) {
                    debug.group(() => `Trying ${tName}`);
                    const castOp = new federation_internals_1.FragmentElement(currentType, tName);
                    const implemOptions = advanceSimultaneousPathsWithOperation(supergraphSchema, new SimultaneousPathsWithLazyIndirectPaths([path], context, conditionResolver), castOp);
                    if (!implemOptions) {
                        debug.groupEnd();
                        debug.groupEnd(() => `Cannot advance into ${tName} from ${currentType}: no options for ${operation}.`);
                        return { options: undefined };
                    }
                    if (implemOptions.length === 0) {
                        debug.groupEnd(() => `Cannot ever get ${tName} from this branch, ignoring it`);
                        continue;
                    }
                    debug.groupEnd(() => `Advanced into ${tName} from ${currentType}: ${advanceOptionsToString(implemOptions)}`);
                    optionsByImplems.push(implemOptions.map(opt => opt.paths));
                }
                const allCastOptions = flatCartesianProduct(optionsByImplems);
                debug.groupEnd(() => `Type-exploded options: ${advanceOptionsToString(allCastOptions)}`);
                return { options: allCastOptions };
            case 'ObjectType':
                const conditionType = supergraphSchema.type(typeName);
                if ((0, federation_internals_1.isAbstractType)(conditionType) && (0, federation_internals_1.possibleRuntimeTypes)(conditionType).some(t => t.name == currentType.name)) {
                    debug.groupEnd(() => `${typeName} is a super-type of current type ${currentType}: no edge to take`);
                    const updatedPath = operation.appliedDirectives.length > 0
                        ? path.add(operation, null, exports.noConditionsResolution, operation.deferDirectiveArgs())
                        : path;
                    return { options: [[updatedPath]] };
                }
                if (path.tailIsInterfaceObject()) {
                    const fakeDownCastEdge = path.nextEdges().find((e) => e.transition.kind === 'InterfaceObjectFakeDownCast' && e.transition.castedTypeName === typeName);
                    if (fakeDownCastEdge) {
                        const conditionResolution = canSatisfyConditions(path, fakeDownCastEdge, conditionResolver, context, [], []);
                        if (!conditionResolution.satisfied) {
                            return { options: undefined };
                        }
                        const updatedPath = path.add(operation, fakeDownCastEdge, conditionResolution, operation.deferDirectiveArgs());
                        return { options: [[updatedPath]] };
                    }
                }
                debug.groupEnd(() => `Cannot ever get ${typeName} from current type ${currentType}: returning empty branch`);
                return { options: [] };
            default:
                (0, federation_internals_1.assert)(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
        }
    }
}
function addFieldEdge(path, fieldOperation, edge, conditionResolver, context) {
    const conditionResolution = canSatisfyConditions(path, edge, conditionResolver, context, [], []);
    return conditionResolution.satisfied ? path.add(fieldOperation, edge, conditionResolution) : undefined;
}
function pathAsOptions(path) {
    return path ? [[path]] : undefined;
}
function nextEdgeForField(path, field) {
    return edgeForField(path.graph, path.tail, field);
}
function edgeForField(graph, vertex, field) {
    const candidates = graph.outEdges(vertex).filter(e => e.transition.kind === 'FieldCollection' && field.selects(e.transition.definition, true));
    (0, federation_internals_1.assert)(candidates.length <= 1, () => `Vertex ${vertex} has multiple edges matching ${field} (${candidates})`);
    return candidates.length === 0 ? undefined : candidates[0];
}
function nextEdgeForTypeCast(path, typeName) {
    return edgeForTypeCast(path.graph, path.tail, typeName);
}
function edgeForTypeCast(graph, vertex, typeName) {
    const candidates = graph.outEdges(vertex).filter(e => e.transition.kind === 'DownCast' && typeName === e.transition.castedType.name);
    (0, federation_internals_1.assert)(candidates.length <= 1, () => `Vertex ${vertex} has multiple edges matching ${typeName} (${candidates})`);
    return candidates.length === 0 ? undefined : candidates[0];
}
//# sourceMappingURL=graphPath.js.map