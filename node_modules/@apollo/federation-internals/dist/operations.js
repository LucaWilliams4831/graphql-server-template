"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.operationToDocument = exports.parseSelectionSet = exports.parseOperation = exports.operationFromDocument = exports.FragmentSelection = exports.FieldSelection = exports.selectionOfElement = exports.selectionSetOfElement = exports.selectionSetOf = exports.allFieldDefinitionsInSelectionSet = exports.MutableSelectionSet = exports.SelectionSetUpdates = exports.SelectionSet = exports.NamedFragments = exports.NamedFragmentDefinition = exports.Operation = exports.concatOperationPaths = exports.conditionalDirectivesInOperationPath = exports.sameOperationPaths = exports.operationPathToStringPath = exports.FragmentElement = exports.Field = void 0;
const graphql_1 = require("graphql");
const definitions_1 = require("./definitions");
const federation_1 = require("./federation");
const error_1 = require("./error");
const types_1 = require("./types");
const utils_1 = require("./utils");
const values_1 = require("./values");
const uuid_1 = require("uuid");
function validate(condition, message, sourceAST) {
    if (!condition) {
        throw error_1.ERRORS.INVALID_GRAPHQL.err(message(), { nodes: sourceAST });
    }
}
function haveSameDirectives(op1, op2) {
    return (0, definitions_1.sameDirectiveApplications)(op1.appliedDirectives, op2.appliedDirectives);
}
class AbstractOperationElement extends definitions_1.DirectiveTargetElement {
    constructor(schema, directives) {
        super(schema, directives);
    }
    collectVariables(collector) {
        this.collectVariablesInElement(collector);
        this.collectVariablesInAppliedDirectives(collector);
    }
    addAttachement(key, value) {
        if (!this.attachements) {
            this.attachements = new Map();
        }
        this.attachements.set(key, value);
    }
    getAttachement(key) {
        var _a;
        return (_a = this.attachements) === null || _a === void 0 ? void 0 : _a.get(key);
    }
    copyAttachementsTo(elt) {
        if (this.attachements) {
            for (const [k, v] of this.attachements.entries()) {
                elt.addAttachement(k, v);
            }
        }
    }
}
class Field extends AbstractOperationElement {
    constructor(definition, args, directives, alias) {
        super(definition.schema(), directives);
        this.definition = definition;
        this.args = args;
        this.alias = alias;
        this.kind = 'Field';
    }
    collectVariablesInElement(collector) {
        if (this.args) {
            collector.collectInArguments(this.args);
        }
    }
    get name() {
        return this.definition.name;
    }
    argumentValue(name) {
        return this.args ? this.args[name] : undefined;
    }
    responseName() {
        return this.alias ? this.alias : this.name;
    }
    key() {
        return this.responseName();
    }
    asPathElement() {
        return this.responseName();
    }
    get parentType() {
        return this.definition.parent;
    }
    isLeafField() {
        return (0, definitions_1.isLeafType)((0, definitions_1.baseType)(this.definition.type));
    }
    withUpdatedDefinition(newDefinition) {
        const newField = new Field(newDefinition, this.args, this.appliedDirectives, this.alias);
        this.copyAttachementsTo(newField);
        return newField;
    }
    withUpdatedAlias(newAlias) {
        const newField = new Field(this.definition, this.args, this.appliedDirectives, newAlias);
        this.copyAttachementsTo(newField);
        return newField;
    }
    withUpdatedDirectives(newDirectives) {
        const newField = new Field(this.definition, this.args, newDirectives, this.alias);
        this.copyAttachementsTo(newField);
        return newField;
    }
    argumentsToNodes() {
        if (!this.args) {
            return undefined;
        }
        const entries = Object.entries(this.args);
        if (entries.length === 0) {
            return undefined;
        }
        return entries.map(([n, v]) => {
            return {
                kind: graphql_1.Kind.ARGUMENT,
                name: { kind: graphql_1.Kind.NAME, value: n },
                value: (0, values_1.valueToAST)(v, this.definition.argument(n).type),
            };
        });
    }
    appliesTo(type) {
        const definition = type.field(this.name);
        return !!definition && this.selects(definition);
    }
    selects(definition, assumeValid = false, variableDefinitions) {
        (0, utils_1.assert)(assumeValid || variableDefinitions, 'Must provide variable definitions if validation is needed');
        if (definition === this.definition) {
            return true;
        }
        if (this.name !== definition.name) {
            return false;
        }
        for (const argDef of definition.arguments()) {
            const appliedValue = this.argumentValue(argDef.name);
            if (appliedValue === undefined) {
                if (argDef.defaultValue === undefined && !(0, definitions_1.isNullableType)(argDef.type)) {
                    return false;
                }
            }
            else {
                if (!assumeValid && !(0, values_1.isValidValue)(appliedValue, argDef, variableDefinitions)) {
                    return false;
                }
            }
        }
        if (!assumeValid && this.args) {
            for (const [name, value] of Object.entries(this.args)) {
                if (value !== null && definition.argument(name) === undefined) {
                    return false;
                }
            }
        }
        return true;
    }
    validate(variableDefinitions) {
        validate(this.name === this.definition.name, () => `Field name "${this.name}" cannot select field "${this.definition.coordinate}: name mismatch"`);
        for (const argDef of this.definition.arguments()) {
            const appliedValue = this.argumentValue(argDef.name);
            if (appliedValue === undefined) {
                validate(argDef.defaultValue !== undefined || (0, definitions_1.isNullableType)(argDef.type), () => `Missing mandatory value for argument "${argDef.name}" of field "${this.definition.coordinate}" in selection "${this}"`);
            }
            else {
                validate((0, values_1.isValidValue)(appliedValue, argDef, variableDefinitions), () => `Invalid value ${(0, values_1.valueToString)(appliedValue)} for argument "${argDef.coordinate}" of type ${argDef.type}`);
            }
        }
        if (this.args) {
            for (const [name, value] of Object.entries(this.args)) {
                validate(value === null || this.definition.argument(name) !== undefined, () => `Unknown argument "${name}" in field application of "${this.name}"`);
            }
        }
    }
    rebaseOn(parentType) {
        const fieldParent = this.definition.parent;
        if (parentType === fieldParent) {
            return this;
        }
        if (this.name === definitions_1.typenameFieldName) {
            return this.withUpdatedDefinition(parentType.typenameField());
        }
        validate(this.canRebaseOn(parentType), () => `Cannot add selection of field "${this.definition.coordinate}" to selection set of parent type "${parentType}"`);
        const fieldDef = parentType.field(this.name);
        validate(fieldDef, () => `Cannot add selection of field "${this.definition.coordinate}" to selection set of parent type "${parentType}" (that does not declare that field)`);
        return this.withUpdatedDefinition(fieldDef);
    }
    canRebaseOn(parentType) {
        const fieldParentType = this.definition.parent;
        return parentType.name === fieldParentType.name
            || (0, definitions_1.isInterfaceType)(fieldParentType)
            || (0, federation_1.isInterfaceObjectType)(fieldParentType);
    }
    typeIfAddedTo(parentType) {
        var _a, _b;
        const fieldParentType = this.definition.parent;
        if (parentType == fieldParentType) {
            return this.definition.type;
        }
        if (this.name === definitions_1.typenameFieldName) {
            return (_a = parentType.typenameField()) === null || _a === void 0 ? void 0 : _a.type;
        }
        return this.canRebaseOn(parentType)
            ? (_b = parentType.field(this.name)) === null || _b === void 0 ? void 0 : _b.type
            : undefined;
    }
    hasDefer() {
        return false;
    }
    deferDirectiveArgs() {
        return undefined;
    }
    withoutDefer() {
        return this;
    }
    equals(that) {
        if (this === that) {
            return true;
        }
        return that.kind === 'Field'
            && this.name === that.name
            && this.alias === that.alias
            && (this.args ? that.args && (0, values_1.argumentsEquals)(this.args, that.args) : !that.args)
            && haveSameDirectives(this, that);
    }
    toString() {
        const alias = this.alias ? this.alias + ': ' : '';
        const entries = this.args ? Object.entries(this.args) : [];
        const args = entries.length === 0
            ? ''
            : '(' + entries.map(([n, v]) => { var _a; return `${n}: ${(0, values_1.valueToString)(v, (_a = this.definition.argument(n)) === null || _a === void 0 ? void 0 : _a.type)}`; }).join(', ') + ')';
        return alias + this.name + args + this.appliedDirectivesToString();
    }
}
exports.Field = Field;
function keyForDirective(directive, directivesNeverEqualToThemselves = ['defer']) {
    if (directivesNeverEqualToThemselves.includes(directive.name)) {
        return (0, uuid_1.v1)();
    }
    const entries = Object.entries(directive.arguments()).filter(([_, v]) => v !== undefined);
    entries.sort(([n1], [n2]) => n1.localeCompare(n2));
    const args = entries.length == 0 ? '' : '(' + entries.map(([n, v]) => `${n}: ${(0, values_1.valueToString)(v, directive.argumentType(n))}`).join(', ') + ')';
    return `@${directive.name}${args}`;
}
class FragmentElement extends AbstractOperationElement {
    constructor(sourceType, typeCondition, directives) {
        super(sourceType.schema(), directives);
        this.sourceType = sourceType;
        this.kind = 'FragmentElement';
        this.typeCondition = typeCondition !== undefined && typeof typeCondition === 'string'
            ? this.schema().type(typeCondition)
            : typeCondition;
    }
    collectVariablesInElement(_) {
    }
    get parentType() {
        return this.sourceType;
    }
    key() {
        if (!this.computedKey) {
            const keyForDirectives = this.appliedDirectives.map((d) => keyForDirective(d)).join(' ');
            this.computedKey = '...' + (this.typeCondition ? ' on ' + this.typeCondition.name : '') + keyForDirectives;
        }
        return this.computedKey;
    }
    castedType() {
        return this.typeCondition ? this.typeCondition : this.sourceType;
    }
    asPathElement() {
        const condition = this.typeCondition;
        return condition ? `... on ${condition}` : undefined;
    }
    withUpdatedSourceType(newSourceType) {
        return this.withUpdatedTypes(newSourceType, this.typeCondition);
    }
    withUpdatedCondition(newCondition) {
        return this.withUpdatedTypes(this.sourceType, newCondition);
    }
    withUpdatedTypes(newSourceType, newCondition) {
        const newFragment = new FragmentElement(newSourceType, newCondition === null || newCondition === void 0 ? void 0 : newCondition.name, this.appliedDirectives);
        this.copyAttachementsTo(newFragment);
        return newFragment;
    }
    withUpdatedDirectives(newDirectives) {
        const newFragment = new FragmentElement(this.sourceType, this.typeCondition, newDirectives);
        this.copyAttachementsTo(newFragment);
        return newFragment;
    }
    rebaseOn(parentType) {
        const fragmentParent = this.parentType;
        const typeCondition = this.typeCondition;
        if (parentType === fragmentParent) {
            return this;
        }
        const { canRebase, rebasedCondition } = this.canRebaseOn(parentType);
        validate(canRebase, () => `Cannot add fragment of condition "${typeCondition}" (runtimes: [${(0, definitions_1.possibleRuntimeTypes)(typeCondition)}]) to parent type "${parentType}" (runtimes: ${(0, definitions_1.possibleRuntimeTypes)(parentType)})`);
        return this.withUpdatedTypes(parentType, rebasedCondition);
    }
    canRebaseOn(parentType) {
        if (!this.typeCondition) {
            return { canRebase: true, rebasedCondition: undefined };
        }
        const rebasedCondition = parentType.schema().type(this.typeCondition.name);
        if (!rebasedCondition || !(0, definitions_1.isCompositeType)(rebasedCondition) || !(0, definitions_1.runtimeTypesIntersects)(parentType, rebasedCondition)) {
            return { canRebase: false };
        }
        return { canRebase: true, rebasedCondition };
    }
    castedTypeIfAddedTo(parentType) {
        if (parentType == this.parentType) {
            return this.castedType();
        }
        const { canRebase, rebasedCondition } = this.canRebaseOn(parentType);
        return canRebase ? (rebasedCondition ? rebasedCondition : parentType) : undefined;
    }
    hasDefer() {
        return this.hasAppliedDirective('defer');
    }
    hasStream() {
        return this.hasAppliedDirective('stream');
    }
    deferDirectiveArgs() {
        var _a;
        return (_a = this.appliedDirectivesOf(this.schema().deferDirective())[0]) === null || _a === void 0 ? void 0 : _a.arguments();
    }
    withoutDefer() {
        const deferName = this.schema().deferDirective().name;
        const updatedDirectives = this.appliedDirectives.filter((d) => d.name !== deferName);
        if (!this.typeCondition && updatedDirectives.length === 0) {
            return undefined;
        }
        if (updatedDirectives.length === this.appliedDirectives.length) {
            return this;
        }
        const updated = new FragmentElement(this.sourceType, this.typeCondition, updatedDirectives);
        this.copyAttachementsTo(updated);
        return updated;
    }
    withNormalizedDefer(normalizer) {
        const deferArgs = this.deferDirectiveArgs();
        if (!deferArgs) {
            return this;
        }
        let newDeferArgs = undefined;
        let conditionVariable = undefined;
        if (deferArgs.if !== undefined) {
            if (typeof deferArgs.if === 'boolean') {
                if (deferArgs.if) {
                    newDeferArgs = {
                        ...deferArgs,
                        if: undefined,
                    };
                }
                else {
                    return this.withoutDefer();
                }
            }
            else {
                conditionVariable = deferArgs.if;
            }
        }
        let label = deferArgs.label;
        if (!label) {
            label = normalizer.newLabel();
            if (newDeferArgs) {
                newDeferArgs.label = label;
            }
            else {
                newDeferArgs = {
                    ...deferArgs,
                    label,
                };
            }
        }
        if (conditionVariable) {
            normalizer.registerCondition(label, conditionVariable);
        }
        if (!newDeferArgs) {
            return this;
        }
        const deferDirective = this.schema().deferDirective();
        const updatedDirectives = this.appliedDirectives
            .filter((d) => d.name !== deferDirective.name)
            .concat(new definitions_1.Directive(deferDirective.name, newDeferArgs));
        const updated = new FragmentElement(this.sourceType, this.typeCondition, updatedDirectives);
        this.copyAttachementsTo(updated);
        return updated;
    }
    equals(that) {
        var _a, _b;
        if (this === that) {
            return true;
        }
        return that.kind === 'FragmentElement'
            && ((_a = this.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === ((_b = that.typeCondition) === null || _b === void 0 ? void 0 : _b.name)
            && haveSameDirectives(this, that);
    }
    toString() {
        return '...' + (this.typeCondition ? ' on ' + this.typeCondition : '') + this.appliedDirectivesToString();
    }
}
exports.FragmentElement = FragmentElement;
function operationPathToStringPath(path) {
    return path
        .filter((p) => !(p.kind === 'FragmentElement' && !p.typeCondition))
        .map((p) => { var _a; return p.kind === 'Field' ? p.responseName() : `... on ${(_a = p.typeCondition) === null || _a === void 0 ? void 0 : _a.coordinate}`; });
}
exports.operationPathToStringPath = operationPathToStringPath;
function sameOperationPaths(p1, p2) {
    if (p1 === p2) {
        return true;
    }
    if (p1.length !== p2.length) {
        return false;
    }
    for (let i = 0; i < p1.length; i++) {
        if (!p1[i].equals(p2[i])) {
            return false;
        }
    }
    return true;
}
exports.sameOperationPaths = sameOperationPaths;
function conditionalDirectivesInOperationPath(path) {
    return path.map((e) => e.appliedDirectives).flat().filter((d) => (0, definitions_1.isConditionalDirective)(d));
}
exports.conditionalDirectivesInOperationPath = conditionalDirectivesInOperationPath;
function concatOperationPaths(head, tail) {
    if (head.length === 0) {
        return tail;
    }
    if (tail.length === 0) {
        return head;
    }
    const lastOfHead = head[head.length - 1];
    const conditionals = conditionalDirectivesInOperationPath(head);
    let firstOfTail = tail[0];
    while (firstOfTail && isUselessFollowupElement(lastOfHead, firstOfTail, conditionals)) {
        tail = tail.slice(1);
        firstOfTail = tail[0];
    }
    return head.concat(tail);
}
exports.concatOperationPaths = concatOperationPaths;
function isUselessFollowupElement(first, followup, conditionals) {
    const typeOfFirst = first.kind === 'Field'
        ? (0, definitions_1.baseType)(first.definition.type)
        : first.typeCondition;
    return !!typeOfFirst
        && followup.kind === 'FragmentElement'
        && !!followup.typeCondition
        && (followup.appliedDirectives.length === 0 || (0, definitions_1.isDirectiveApplicationsSubset)(conditionals, followup.appliedDirectives))
        && (0, types_1.isSubtype)(followup.typeCondition, typeOfFirst);
}
class Operation {
    constructor(schema, rootKind, selectionSet, variableDefinitions, name) {
        this.schema = schema;
        this.rootKind = rootKind;
        this.selectionSet = selectionSet;
        this.variableDefinitions = variableDefinitions;
        this.name = name;
    }
    optimize(fragments, minUsagesToOptimize = 2) {
        var _a;
        (0, utils_1.assert)(minUsagesToOptimize >= 1, `Expected 'minUsagesToOptimize' to be at least 1, but got ${minUsagesToOptimize}`);
        if (!fragments || fragments.isEmpty()) {
            return this;
        }
        let optimizedSelection = this.selectionSet.optimize(fragments);
        if (optimizedSelection === this.selectionSet) {
            return this;
        }
        const usages = new Map();
        optimizedSelection.collectUsedFragmentNames(usages);
        for (const fragment of fragments.names()) {
            if (!usages.has(fragment)) {
                usages.set(fragment, 0);
            }
        }
        const toDeoptimize = (0, utils_1.mapEntries)(usages).filter(([_, count]) => count < minUsagesToOptimize).map(([name]) => name);
        const newFragments = (_a = optimizedSelection.fragments) === null || _a === void 0 ? void 0 : _a.without(toDeoptimize);
        optimizedSelection = optimizedSelection.expandFragments(toDeoptimize, newFragments);
        return new Operation(this.schema, this.rootKind, optimizedSelection, this.variableDefinitions, this.name);
    }
    expandAllFragments() {
        const expandedSelections = this.selectionSet.expandAllFragments();
        if (expandedSelections === this.selectionSet) {
            return this;
        }
        return new Operation(this.schema, this.rootKind, expandedSelections, this.variableDefinitions, this.name);
    }
    trimUnsatisfiableBranches() {
        const trimmedSelections = this.selectionSet.trimUnsatisfiableBranches(this.selectionSet.parentType);
        if (trimmedSelections === this.selectionSet) {
            return this;
        }
        return new Operation(this.schema, this.rootKind, trimmedSelections, this.variableDefinitions, this.name);
    }
    withoutDefer(labelsToRemove) {
        (0, utils_1.assert)(!this.selectionSet.fragments || this.selectionSet.fragments.isEmpty(), 'Removing @defer currently only work on "expanded" selections (no named fragments)');
        const updated = this.selectionSet.withoutDefer(labelsToRemove);
        return updated == this.selectionSet
            ? this
            : new Operation(this.schema, this.rootKind, updated, this.variableDefinitions, this.name);
    }
    withNormalizedDefer() {
        (0, utils_1.assert)(!this.selectionSet.fragments || this.selectionSet.fragments.isEmpty(), 'Assigning @defer lables currently only work on "expanded" selections (no named fragments)');
        const normalizer = new DeferNormalizer();
        const { hasDefers, hasNonLabelledOrConditionalDefers } = normalizer.init(this.selectionSet);
        let updatedOperation = this;
        if (hasNonLabelledOrConditionalDefers) {
            const updated = this.selectionSet.withNormalizedDefer(normalizer);
            updatedOperation = new Operation(this.schema, this.rootKind, updated, this.variableDefinitions, this.name);
        }
        return {
            operation: updatedOperation,
            hasDefers,
            assignedDeferLabels: normalizer.assignedLabels,
            deferConditions: normalizer.deferConditions,
        };
    }
    collectDefaultedVariableValues() {
        const defaultedVariableValues = {};
        for (const { variable, defaultValue } of this.variableDefinitions.definitions()) {
            if (defaultValue !== undefined) {
                defaultedVariableValues[variable.name] = defaultValue;
            }
        }
        return defaultedVariableValues;
    }
    toString(expandFragments = false, prettyPrint = true) {
        return this.selectionSet.toOperationString(this.rootKind, this.variableDefinitions, this.name, expandFragments, prettyPrint);
    }
}
exports.Operation = Operation;
class NamedFragmentDefinition extends definitions_1.DirectiveTargetElement {
    constructor(schema, name, typeCondition, directives) {
        super(schema, directives);
        this.name = name;
        this.typeCondition = typeCondition;
    }
    setSelectionSet(selectionSet) {
        (0, utils_1.assert)(!this._selectionSet, 'Attempting to set the selection set of a fragment definition already built');
        this._selectionSet = selectionSet;
        return this;
    }
    get selectionSet() {
        (0, utils_1.assert)(this._selectionSet, () => `Trying to access fragment definition ${this.name} before it is fully built`);
        return this._selectionSet;
    }
    withUpdatedSelectionSet(newSelectionSet) {
        return new NamedFragmentDefinition(this.schema(), this.name, this.typeCondition).setSelectionSet(newSelectionSet);
    }
    collectUsedFragmentNames(collector) {
        this.selectionSet.collectUsedFragmentNames(collector);
    }
    toFragmentDefinitionNode() {
        return {
            kind: graphql_1.Kind.FRAGMENT_DEFINITION,
            name: {
                kind: graphql_1.Kind.NAME,
                value: this.name
            },
            typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: this.typeCondition.name
                }
            },
            selectionSet: this.selectionSet.toSelectionSetNode()
        };
    }
    canApplyAtType(type) {
        const applyAtType = (0, types_1.sameType)(type, this.typeCondition) || (0, definitions_1.runtimeTypesIntersects)(type, this.typeCondition);
        return applyAtType
            && this.validForSchema(type.schema());
    }
    validForSchema(schema) {
        if (schema === this.schema()) {
            return true;
        }
        const typeInSchema = schema.type(this.typeCondition.name);
        if (!typeInSchema || !(0, definitions_1.isCompositeType)(typeInSchema)) {
            return false;
        }
        try {
            this.selectionSet.rebaseOn(typeInSchema);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    toString(indent) {
        return (indent !== null && indent !== void 0 ? indent : '') + `fragment ${this.name} on ${this.typeCondition}${this.appliedDirectivesToString()} ${this.selectionSet.toString(false, true, indent)}`;
    }
}
exports.NamedFragmentDefinition = NamedFragmentDefinition;
class NamedFragments {
    constructor() {
        this.fragments = new utils_1.MapWithCachedArrays();
    }
    isEmpty() {
        return this.fragments.size === 0;
    }
    names() {
        return this.fragments.keys();
    }
    add(fragment) {
        if (this.fragments.has(fragment.name)) {
            throw error_1.ERRORS.INVALID_GRAPHQL.err(`Duplicate fragment name '${fragment}'`);
        }
        this.fragments.set(fragment.name, fragment);
    }
    addIfNotExist(fragment) {
        if (!this.fragments.has(fragment.name)) {
            this.fragments.set(fragment.name, fragment);
        }
    }
    maybeApplyingAtType(type) {
        return this.fragments.values().filter(f => f.canApplyAtType(type));
    }
    without(names) {
        if (!names.some(n => this.fragments.has(n))) {
            return this;
        }
        const newFragments = new NamedFragments();
        for (const fragment of this.fragments.values()) {
            if (!names.includes(fragment.name)) {
                const updatedSelectionSet = fragment.selectionSet.expandFragments(names, newFragments);
                const newFragment = updatedSelectionSet === fragment.selectionSet
                    ? fragment
                    : fragment.withUpdatedSelectionSet(updatedSelectionSet);
                newFragments.add(newFragment);
            }
        }
        return newFragments.isEmpty() ? undefined : newFragments;
    }
    get(name) {
        return this.fragments.get(name);
    }
    has(name) {
        return this.fragments.has(name);
    }
    definitions() {
        return this.fragments.values();
    }
    map(mapper) {
        const mapped = new NamedFragments();
        for (const def of this.fragments.values()) {
            mapped.fragments.set(def.name, mapper(def));
        }
        return mapped;
    }
    validate(variableDefinitions) {
        for (const fragment of this.fragments.values()) {
            fragment.selectionSet.validate(variableDefinitions);
        }
    }
    toFragmentDefinitionNodes() {
        return this.definitions().map(f => f.toFragmentDefinitionNode());
    }
    toString(indent) {
        return this.definitions().map(f => f.toString(indent)).join('\n\n');
    }
}
exports.NamedFragments = NamedFragments;
class DeferNormalizer {
    constructor() {
        this.index = 0;
        this.assignedLabels = new Set();
        this.deferConditions = new utils_1.SetMultiMap();
        this.usedLabels = new Set();
    }
    init(selectionSet) {
        let hasNonLabelledOrConditionalDefers = false;
        let hasDefers = false;
        const stack = selectionSet.selections().concat();
        while (stack.length > 0) {
            const selection = stack.pop();
            if (selection.kind === 'FragmentSelection') {
                const deferArgs = selection.element.deferDirectiveArgs();
                if (deferArgs) {
                    hasDefers = true;
                    if (!deferArgs.label || deferArgs.if !== undefined) {
                        hasNonLabelledOrConditionalDefers = true;
                    }
                    if (deferArgs.label) {
                        this.usedLabels.add(deferArgs.label);
                    }
                }
            }
            if (selection.selectionSet) {
                selection.selectionSet.selections().forEach((s) => stack.push(s));
            }
        }
        return { hasDefers, hasNonLabelledOrConditionalDefers };
    }
    nextLabel() {
        return `qp__${this.index++}`;
    }
    newLabel() {
        let candidate = this.nextLabel();
        while (this.usedLabels.has(candidate)) {
            candidate = this.nextLabel();
        }
        this.assignedLabels.add(candidate);
        return candidate;
    }
    registerCondition(label, condition) {
        this.deferConditions.add(condition.name, label);
    }
}
class SelectionSet {
    constructor(parentType, keyedSelections = new Map(), fragments) {
        this.parentType = parentType;
        this.fragments = fragments;
        this._keyedSelections = keyedSelections;
        this._selections = (0, utils_1.mapValues)(keyedSelections);
    }
    selectionsInReverseOrder() {
        const length = this._selections.length;
        const reversed = new Array(length);
        for (let i = 0; i < length; i++) {
            reversed[i] = this._selections[length - i - 1];
        }
        return reversed;
    }
    selections() {
        return this._selections;
    }
    hasTopLevelTypenameField() {
        return this._keyedSelections.has(definitions_1.typenameFieldName);
    }
    fieldsInSet() {
        const fields = new Array();
        for (const selection of this.selections()) {
            if (selection.kind === 'FieldSelection') {
                fields.push({ path: [], field: selection });
            }
            else {
                const condition = selection.element.typeCondition;
                const header = condition ? [`... on ${condition}`] : [];
                for (const { path, field } of selection.selectionSet.fieldsInSet()) {
                    fields.push({ path: header.concat(path), field });
                }
            }
        }
        return fields;
    }
    usedVariables() {
        const collector = new definitions_1.VariableCollector();
        this.collectVariables(collector);
        return collector.variables();
    }
    collectVariables(collector) {
        for (const selection of this.selections()) {
            selection.collectVariables(collector);
        }
    }
    collectUsedFragmentNames(collector) {
        for (const selection of this.selections()) {
            selection.collectUsedFragmentNames(collector);
        }
    }
    optimize(fragments) {
        if (!fragments || fragments.isEmpty()) {
            return this;
        }
        (0, utils_1.assert)(!this.fragments || this.fragments.isEmpty(), `Should not be called on selection that already has named fragments, but got ${this.fragments}`);
        return this.lazyMap((selection) => selection.optimize(fragments), { fragments });
    }
    expandAllFragments() {
        return this.lazyMap((selection) => selection.expandAllFragments(), { fragments: null });
    }
    expandFragments(names, updatedFragments) {
        if (names.length === 0) {
            return this;
        }
        return this.lazyMap((selection) => selection.expandFragments(names, updatedFragments), { fragments: updatedFragments !== null && updatedFragments !== void 0 ? updatedFragments : null });
    }
    trimUnsatisfiableBranches(parentType) {
        return this.lazyMap((selection) => selection.trimUnsatisfiableBranches(parentType), { parentType });
    }
    lazyMap(mapper, options) {
        var _a;
        const selections = this.selections();
        const updatedFragments = options === null || options === void 0 ? void 0 : options.fragments;
        const newFragments = updatedFragments === undefined ? this.fragments : (updatedFragments !== null && updatedFragments !== void 0 ? updatedFragments : undefined);
        let updatedSelections = undefined;
        for (let i = 0; i < selections.length; i++) {
            const selection = selections[i];
            const updated = mapper(selection);
            if (updated !== selection && !updatedSelections) {
                updatedSelections = new SelectionSetUpdates();
                for (let j = 0; j < i; j++) {
                    updatedSelections.add(selections[j]);
                }
            }
            if (!!updated && updatedSelections) {
                updatedSelections.add(updated);
            }
        }
        if (!updatedSelections) {
            return this.withUpdatedFragments(newFragments);
        }
        return updatedSelections.toSelectionSet((_a = options === null || options === void 0 ? void 0 : options.parentType) !== null && _a !== void 0 ? _a : this.parentType, newFragments);
    }
    withUpdatedFragments(newFragments) {
        return this.fragments === newFragments ? this : new SelectionSet(this.parentType, this._keyedSelections, newFragments);
    }
    withoutDefer(labelsToRemove) {
        (0, utils_1.assert)(!this.fragments, 'Not yet supported');
        return this.lazyMap((selection) => selection.withoutDefer(labelsToRemove));
    }
    withNormalizedDefer(normalizer) {
        (0, utils_1.assert)(!this.fragments, 'Not yet supported');
        return this.lazyMap((selection) => selection.withNormalizedDefer(normalizer));
    }
    hasDefer() {
        return this.selections().some((s) => s.hasDefer());
    }
    filter(predicate) {
        return this.lazyMap((selection) => selection.filter(predicate));
    }
    withoutEmptyBranches() {
        const updated = this.filter((selection) => { var _a; return ((_a = selection.selectionSet) === null || _a === void 0 ? void 0 : _a.isEmpty()) !== true; });
        return updated.isEmpty() ? undefined : updated;
    }
    rebaseOn(parentType) {
        if (this.parentType === parentType) {
            return this;
        }
        const newSelections = new Map();
        for (const selection of this.selections()) {
            newSelections.set(selection.key(), selection.rebaseOn(parentType));
        }
        return new SelectionSet(parentType, newSelections, this.fragments);
    }
    equals(that) {
        if (this === that) {
            return true;
        }
        if (this._selections.length !== that._selections.length) {
            return false;
        }
        for (const [key, thisSelection] of this._keyedSelections) {
            const thatSelection = that._keyedSelections.get(key);
            if (!thatSelection || !thisSelection.equals(thatSelection)) {
                return false;
            }
        }
        return true;
    }
    triviallyNestedSelectionsForKey(parentType, key) {
        const found = [];
        for (const selection of this.selections()) {
            if (selection.isUnecessaryInlineFragment(parentType)) {
                const selectionForKey = selection.selectionSet._keyedSelections.get(key);
                if (selectionForKey) {
                    found.push(selectionForKey);
                }
                for (const nestedSelection of selection.selectionSet.triviallyNestedSelectionsForKey(parentType, key)) {
                    found.push(nestedSelection);
                }
            }
        }
        return found;
    }
    mergeSameKeySelections(selections) {
        if (selections.length === 0) {
            return undefined;
        }
        const first = selections[0];
        if (!first.selectionSet || (first instanceof FragmentSpreadSelection) || selections.length === 1) {
            return first;
        }
        const mergedSubselections = new SelectionSetUpdates();
        for (const selection of selections) {
            mergedSubselections.add(selection.selectionSet);
        }
        return first.withUpdatedSelectionSet(mergedSubselections.toSelectionSet(first.selectionSet.parentType));
    }
    contains(that) {
        for (const [key, thatSelection] of that._keyedSelections) {
            const thisSelection = this._keyedSelections.get(key);
            const otherSelections = this.triviallyNestedSelectionsForKey(this.parentType, key);
            const mergedSelection = this.mergeSameKeySelections([thisSelection].concat(otherSelections).filter(utils_1.isDefined));
            if (!(mergedSelection && mergedSelection.contains(thatSelection))
                && !(thatSelection.isUnecessaryInlineFragment(this.parentType) && this.contains(thatSelection.selectionSet))) {
                return false;
            }
        }
        return true;
    }
    diffIfContains(that) {
        if (this.contains(that)) {
            const diff = this.minus(that);
            return { contains: true, diff: diff.isEmpty() ? undefined : diff };
        }
        return { contains: false };
    }
    minus(that) {
        const updated = new SelectionSetUpdates();
        for (const [key, thisSelection] of this._keyedSelections) {
            const thatSelection = that._keyedSelections.get(key);
            const otherSelections = that.triviallyNestedSelectionsForKey(this.parentType, key);
            const allSelections = thatSelection ? [thatSelection].concat(otherSelections) : otherSelections;
            if (allSelections.length === 0) {
                updated.add(thisSelection);
            }
            else {
                const selectionDiff = allSelections.reduce((prev, val) => prev === null || prev === void 0 ? void 0 : prev.minus(val), thisSelection);
                if (selectionDiff) {
                    updated.add(selectionDiff);
                }
            }
        }
        return updated.toSelectionSet(this.parentType, this.fragments);
    }
    canRebaseOn(parentTypeToTest) {
        return this.selections().every((selection) => selection.canAddTo(parentTypeToTest));
    }
    validate(variableDefinitions) {
        validate(!this.isEmpty(), () => `Invalid empty selection set`);
        for (const selection of this.selections()) {
            selection.validate(variableDefinitions);
        }
    }
    isEmpty() {
        return this._selections.length === 0;
    }
    toSelectionSetNode() {
        if (this.isEmpty()) {
            return {
                kind: graphql_1.Kind.SELECTION_SET,
                selections: [{
                        kind: graphql_1.Kind.FIELD,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: '...',
                        },
                    }]
            };
        }
        return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: Array.from(this.selectionsInPrintOrder(), s => s.toSelectionNode())
        };
    }
    selectionsInPrintOrder() {
        const isNonAliasedTypenameSelection = (s) => s.kind === 'FieldSelection' && !s.element.alias && s.element.name === definitions_1.typenameFieldName;
        const typenameSelection = this._selections.find((s) => isNonAliasedTypenameSelection(s));
        if (typenameSelection) {
            return [typenameSelection].concat(this.selections().filter(s => !isNonAliasedTypenameSelection(s)));
        }
        else {
            return this._selections;
        }
    }
    toOperationPaths() {
        return this.toOperationPathsInternal([]);
    }
    toOperationPathsInternal(parentPaths) {
        return this.selections().flatMap((selection) => {
            const updatedPaths = parentPaths.map(path => path.concat(selection.element));
            return selection.selectionSet
                ? selection.selectionSet.toOperationPathsInternal(updatedPaths)
                : updatedPaths;
        });
    }
    forEachElement(callback) {
        var _a;
        const stack = this.selectionsInReverseOrder().concat();
        while (stack.length > 0) {
            const selection = stack.pop();
            callback(selection.element);
            (_a = selection.selectionSet) === null || _a === void 0 ? void 0 : _a.selectionsInReverseOrder().forEach((s) => stack.push(s));
        }
    }
    some(predicate) {
        for (const selection of this.selections()) {
            if (predicate(selection.element) || (selection.selectionSet && selection.selectionSet.some(predicate))) {
                return true;
            }
        }
        return false;
    }
    toOperationString(rootKind, variableDefinitions, operationName, expandFragments = false, prettyPrint = true) {
        const indent = prettyPrint ? '' : undefined;
        const fragmentsDefinitions = !expandFragments && this.fragments && !this.fragments.isEmpty()
            ? this.fragments.toString(indent) + "\n\n"
            : "";
        if (rootKind == "query" && !operationName && variableDefinitions.isEmpty()) {
            return fragmentsDefinitions + this.toString(expandFragments, true, indent);
        }
        const nameAndVariables = operationName
            ? " " + (operationName + (variableDefinitions.isEmpty() ? "" : variableDefinitions.toString()))
            : (variableDefinitions.isEmpty() ? "" : " " + variableDefinitions.toString());
        return fragmentsDefinitions + rootKind + nameAndVariables + " " + this.toString(expandFragments, true, indent);
    }
    toString(expandFragments = true, includeExternalBrackets = true, indent) {
        if (this.isEmpty()) {
            return '{}';
        }
        if (indent === undefined) {
            const selectionsToString = this.selections().map(s => s.toString(expandFragments)).join(' ');
            return includeExternalBrackets ? '{ ' + selectionsToString + ' }' : selectionsToString;
        }
        else {
            const selectionIndent = includeExternalBrackets ? indent + "  " : indent;
            const selectionsToString = this.selections().map(s => s.toString(expandFragments, selectionIndent)).join('\n');
            return includeExternalBrackets
                ? '{\n' + selectionsToString + '\n' + indent + '}'
                : selectionsToString;
        }
    }
}
exports.SelectionSet = SelectionSet;
class SelectionSetUpdates {
    constructor() {
        this.keyedUpdates = new utils_1.MultiMap;
    }
    isEmpty() {
        return this.keyedUpdates.size === 0;
    }
    add(selections) {
        addToKeyedUpdates(this.keyedUpdates, selections);
        return this;
    }
    addAtPath(path, selections) {
        if (path.length === 0) {
            if (selections) {
                addToKeyedUpdates(this.keyedUpdates, selections);
            }
        }
        else {
            if (path.length === 1 && !selections) {
                const element = path[0];
                if (element.kind === 'Field' && element.isLeafField()) {
                    const selection = selectionOfElement(element);
                    this.keyedUpdates.add(selection.key(), selection);
                    return this;
                }
            }
            this.keyedUpdates.add(path[0].key(), { path, selections });
        }
        return this;
    }
    clone() {
        const cloned = new SelectionSetUpdates();
        for (const [key, values] of this.keyedUpdates.entries()) {
            cloned.keyedUpdates.set(key, Array.from(values));
        }
        return cloned;
    }
    clear() {
        this.keyedUpdates.clear();
    }
    toSelectionSet(parentType, fragments) {
        return makeSelectionSet(parentType, this.keyedUpdates, fragments);
    }
}
exports.SelectionSetUpdates = SelectionSetUpdates;
function addToKeyedUpdates(keyedUpdates, selections) {
    if (selections instanceof AbstractSelection) {
        addOneToKeyedUpdates(keyedUpdates, selections);
    }
    else {
        const toAdd = selections instanceof SelectionSet ? selections.selections() : selections;
        for (const selection of toAdd) {
            addOneToKeyedUpdates(keyedUpdates, selection);
        }
    }
}
function addOneToKeyedUpdates(keyedUpdates, selection) {
    if (selection instanceof FragmentSpreadSelection) {
        keyedUpdates.set(selection.key(), [selection]);
    }
    else {
        keyedUpdates.add(selection.key(), selection);
    }
}
function maybeRebaseOnSchema(toRebase, schema) {
    if (toRebase.schema() === schema) {
        return toRebase;
    }
    const rebased = schema.type(toRebase.name);
    (0, utils_1.assert)(rebased && (0, definitions_1.isCompositeType)(rebased), () => `Expected ${toRebase} to exists and be composite in the rebased schema, but got ${rebased === null || rebased === void 0 ? void 0 : rebased.kind}`);
    return rebased;
}
function isUnecessaryFragment(parentType, fragment) {
    return fragment.element.appliedDirectives.length === 0
        && (!fragment.element.typeCondition || (0, types_1.isSubtype)(maybeRebaseOnSchema(fragment.element.typeCondition, parentType.schema()), parentType));
}
function withUnecessaryFragmentsRemoved(parentType, selections) {
    if (selections instanceof AbstractSelection) {
        if (selections.kind !== 'FragmentSelection' || !isUnecessaryFragment(parentType, selections)) {
            return selections;
        }
        return withUnecessaryFragmentsRemoved(parentType, selections.selectionSet);
    }
    const toCheck = selections instanceof SelectionSet ? selections.selections() : selections;
    const filtered = [];
    for (const selection of toCheck) {
        if (selection.kind === 'FragmentSelection' && isUnecessaryFragment(parentType, selection)) {
            const subSelections = withUnecessaryFragmentsRemoved(parentType, selection.selectionSet);
            if (subSelections instanceof AbstractSelection) {
                filtered.push(subSelections);
            }
            else {
                for (const subSelection of subSelections) {
                    filtered.push(subSelection);
                }
            }
        }
        else {
            filtered.push(selection);
        }
    }
    return filtered;
}
function makeSelection(parentType, updates, fragments) {
    (0, utils_1.assert)(updates.length > 0, 'Should not be called without any updates');
    const first = updates[0];
    if (updates.length === 1 && first instanceof AbstractSelection) {
        return first.rebaseOn(parentType);
    }
    const element = updateElement(first).rebaseOn(parentType);
    const subSelectionParentType = element.kind === 'Field' ? (0, definitions_1.baseType)(element.definition.type) : element.castedType();
    if (!(0, definitions_1.isCompositeType)(subSelectionParentType)) {
        return selectionOfElement(element);
    }
    const subSelectionKeyedUpdates = new utils_1.MultiMap();
    for (const update of updates) {
        if (update instanceof AbstractSelection) {
            if (update.selectionSet) {
                addToKeyedUpdates(subSelectionKeyedUpdates, update.selectionSet);
            }
        }
        else {
            addSubpathToKeyUpdates(subSelectionKeyedUpdates, subSelectionParentType, update);
        }
    }
    return selectionOfElement(element, makeSelectionSet(subSelectionParentType, subSelectionKeyedUpdates, fragments));
}
function updateElement(update) {
    return update instanceof AbstractSelection ? update.element : update.path[0];
}
function addSubpathToKeyUpdates(keyedUpdates, subSelectionParentType, pathUpdate) {
    if (pathUpdate.path.length === 1) {
        if (!pathUpdate.selections) {
            return;
        }
        addToKeyedUpdates(keyedUpdates, withUnecessaryFragmentsRemoved(subSelectionParentType, pathUpdate.selections));
    }
    else {
        keyedUpdates.add(pathUpdate.path[1].key(), { path: pathUpdate.path.slice(1), selections: pathUpdate.selections });
    }
}
function makeSelectionSet(parentType, keyedUpdates, fragments) {
    const selections = new Map();
    for (const [key, updates] of keyedUpdates.entries()) {
        selections.set(key, makeSelection(parentType, updates, fragments));
    }
    return new SelectionSet(parentType, selections, fragments);
}
class MutableSelectionSet {
    constructor(parentType, _updates, memoizer) {
        this.parentType = parentType;
        this._updates = _updates;
        this.memoizer = memoizer;
    }
    static empty(parentType) {
        return this.emptyWithMemoized(parentType, () => ({}));
    }
    static emptyWithMemoized(parentType, memoizer) {
        return new MutableSelectionSet(parentType, new SelectionSetUpdates(), memoizer);
    }
    static of(selectionSet) {
        return this.ofWithMemoized(selectionSet, () => ({}));
    }
    static ofWithMemoized(selectionSet, memoizer) {
        const s = new MutableSelectionSet(selectionSet.parentType, new SelectionSetUpdates(), memoizer);
        s._updates.add(selectionSet);
        s.computed = selectionSet;
        return s;
    }
    isEmpty() {
        return this._updates.isEmpty();
    }
    get() {
        if (!this.computed) {
            this.computed = this._updates.toSelectionSet(this.parentType);
            this._updates.clear();
            this._updates.add(this.computed);
        }
        return this.computed;
    }
    updates() {
        this.computed = undefined;
        this._memoized = undefined;
        return this._updates;
    }
    clone() {
        const cloned = new MutableSelectionSet(this.parentType, this._updates.clone(), this.memoizer);
        cloned.computed = this.computed;
        cloned._memoized = this._memoized;
        return cloned;
    }
    rebaseOn(parentType) {
        const rebased = new MutableSelectionSet(parentType, new SelectionSetUpdates(), this.memoizer);
        rebased._updates.add(this.get());
        return rebased;
    }
    memoized() {
        if (!this._memoized) {
            this._memoized = this.memoizer(this.get());
        }
        return this._memoized;
    }
    toString() {
        return this.get().toString();
    }
}
exports.MutableSelectionSet = MutableSelectionSet;
function allFieldDefinitionsInSelectionSet(selection) {
    const stack = Array.from(selection.selections());
    const allFields = [];
    while (stack.length > 0) {
        const selection = stack.pop();
        if (selection.kind === 'FieldSelection') {
            allFields.push(selection.element.definition);
        }
        if (selection.selectionSet) {
            stack.push(...selection.selectionSet.selections());
        }
    }
    return allFields;
}
exports.allFieldDefinitionsInSelectionSet = allFieldDefinitionsInSelectionSet;
function selectionSetOf(parentType, selection, fragments) {
    const map = new Map();
    map.set(selection.key(), selection);
    return new SelectionSet(parentType, map, fragments);
}
exports.selectionSetOf = selectionSetOf;
function selectionSetOfElement(element, subSelection, fragments) {
    return selectionSetOf(element.parentType, selectionOfElement(element, subSelection), fragments);
}
exports.selectionSetOfElement = selectionSetOfElement;
function selectionOfElement(element, subSelection) {
    return element.kind === 'Field' ? new FieldSelection(element, subSelection) : new InlineFragmentSelection(element, subSelection);
}
exports.selectionOfElement = selectionOfElement;
class AbstractSelection {
    constructor(element) {
        this.element = element;
    }
    get parentType() {
        return this.element.parentType;
    }
    collectVariables(collector) {
        var _a;
        this.element.collectVariables(collector);
        (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.collectVariables(collector);
    }
    collectUsedFragmentNames(collector) {
        var _a;
        (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.collectUsedFragmentNames(collector);
    }
    namedFragments() {
        var _a;
        return (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.fragments;
    }
    withUpdatedSelectionSet(selectionSet) {
        return this.withUpdatedComponents(this.element, selectionSet);
    }
    withUpdatedElement(element) {
        return this.withUpdatedComponents(element, this.selectionSet);
    }
    mapToSelectionSet(mapper) {
        if (!this.selectionSet) {
            return this.us();
        }
        const updatedSelectionSet = mapper(this.selectionSet);
        return updatedSelectionSet === this.selectionSet
            ? this.us()
            : this.withUpdatedSelectionSet(updatedSelectionSet);
    }
    minus(that) {
        if (this.selectionSet && that.selectionSet) {
            const updatedSubSelectionSet = this.selectionSet.minus(that.selectionSet);
            if (!updatedSubSelectionSet.isEmpty()) {
                return this.withUpdatedSelectionSet(updatedSubSelectionSet);
            }
        }
        return undefined;
    }
    tryOptimizeSubselectionOnce(_) {
        (0, utils_1.assert)(false, `UNSUPPORTED`);
    }
    tryOptimizeSubselectionWithFragments({ parentType, subSelection, fragments, fragmentFilter, }) {
        let candidates = fragments.maybeApplyingAtType(parentType);
        if (fragmentFilter) {
            candidates = candidates.filter(fragmentFilter);
        }
        let shouldTryAgain;
        do {
            const { spread, optimizedSelection, hasDiff } = this.tryOptimizeSubselectionOnce({ parentType, subSelection, candidates, fragments });
            if (optimizedSelection) {
                subSelection = optimizedSelection;
            }
            else if (spread) {
                return spread;
            }
            shouldTryAgain = !!spread && !!hasDiff;
            if (shouldTryAgain) {
                candidates = candidates.filter((c) => c !== (spread === null || spread === void 0 ? void 0 : spread.namedFragment));
            }
        } while (shouldTryAgain);
        return subSelection;
    }
}
class FieldSelection extends AbstractSelection {
    constructor(field, _selectionSet) {
        super(field);
        this._selectionSet = _selectionSet;
        this.kind = 'FieldSelection';
    }
    get selectionSet() {
        return this._selectionSet;
    }
    us() {
        return this;
    }
    withUpdatedComponents(field, selectionSet) {
        return new FieldSelection(field, selectionSet);
    }
    key() {
        return this.element.key();
    }
    optimize(fragments) {
        let optimizedSelection = this.selectionSet ? this.selectionSet.optimize(fragments) : undefined;
        const fieldBaseType = (0, definitions_1.baseType)(this.element.definition.type);
        if ((0, definitions_1.isCompositeType)(fieldBaseType) && optimizedSelection) {
            const optimized = this.tryOptimizeSubselectionWithFragments({
                parentType: fieldBaseType,
                subSelection: optimizedSelection,
                fragments,
                fragmentFilter: (f) => f.appliedDirectives.length === 0,
            });
            (0, utils_1.assert)(!(optimized instanceof FragmentSpreadSelection), 'tryOptimizeSubselectionOnce should never return only a spread');
            optimizedSelection = optimized;
        }
        return this.selectionSet === optimizedSelection
            ? this
            : new FieldSelection(this.element, optimizedSelection);
    }
    tryOptimizeSubselectionOnce({ parentType, subSelection, candidates, fragments, }) {
        let optimizedSelection = subSelection;
        for (const candidate of candidates) {
            const { contains, diff } = optimizedSelection.diffIfContains(candidate.selectionSet);
            if (contains) {
                const spread = new FragmentSpreadSelection(parentType, fragments, candidate, []);
                optimizedSelection = diff
                    ? new SelectionSetUpdates().add(spread).add(diff).toSelectionSet(parentType, fragments)
                    : selectionSetOf(parentType, spread);
                return { spread, optimizedSelection, hasDiff: !!diff };
            }
        }
        return {};
    }
    filter(predicate) {
        if (!this.selectionSet) {
            return predicate(this) ? this : undefined;
        }
        const updatedSelectionSet = this.selectionSet.filter(predicate);
        const thisWithFilteredSelectionSet = this.selectionSet === updatedSelectionSet
            ? this
            : new FieldSelection(this.element, updatedSelectionSet);
        return predicate(thisWithFilteredSelectionSet) ? thisWithFilteredSelectionSet : undefined;
    }
    validate(variableDefinitions) {
        var _a;
        this.element.validate(variableDefinitions);
        validate(this.element.isLeafField() || (this.selectionSet && !this.selectionSet.isEmpty()), () => `Invalid empty selection set for field "${this.element.definition.coordinate}" of non-leaf type ${this.element.definition.type}`, this.element.definition.sourceAST);
        (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.validate(variableDefinitions);
    }
    rebaseOn(parentType) {
        if (this.element.parentType === parentType) {
            return this;
        }
        const rebasedElement = this.element.rebaseOn(parentType);
        if (!this.selectionSet) {
            return this.withUpdatedElement(rebasedElement);
        }
        const rebasedBase = (0, definitions_1.baseType)(rebasedElement.definition.type);
        if (rebasedBase === this.selectionSet.parentType) {
            return this.withUpdatedElement(rebasedElement);
        }
        validate((0, definitions_1.isCompositeType)(rebasedBase), () => `Cannot rebase field selection ${this} on ${parentType}: rebased field base return type ${rebasedBase} is not composite`);
        return this.withUpdatedComponents(rebasedElement, this.selectionSet.rebaseOn(rebasedBase));
    }
    canAddTo(parentType) {
        if (this.element.parentType === parentType) {
            return true;
        }
        const type = this.element.typeIfAddedTo(parentType);
        if (!type) {
            return false;
        }
        const base = (0, definitions_1.baseType)(type);
        if (this.selectionSet && this.selectionSet.parentType !== base) {
            (0, utils_1.assert)((0, definitions_1.isCompositeType)(base), () => `${this.element} should have a selection set as it's type is not a composite`);
            return this.selectionSet.selections().every((s) => s.canAddTo(base));
        }
        return true;
    }
    toSelectionNode() {
        var _a;
        const alias = this.element.alias ? { kind: graphql_1.Kind.NAME, value: this.element.alias, } : undefined;
        return {
            kind: graphql_1.Kind.FIELD,
            name: {
                kind: graphql_1.Kind.NAME,
                value: this.element.name,
            },
            alias,
            arguments: this.element.argumentsToNodes(),
            directives: this.element.appliedDirectivesToDirectiveNodes(),
            selectionSet: (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.toSelectionSetNode()
        };
    }
    withoutDefer(labelsToRemove) {
        return this.mapToSelectionSet((s) => s.withoutDefer(labelsToRemove));
    }
    withNormalizedDefer(normalizer) {
        return this.mapToSelectionSet((s) => s.withNormalizedDefer(normalizer));
    }
    hasDefer() {
        var _a;
        return !!((_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.hasDefer());
    }
    expandAllFragments() {
        return this.mapToSelectionSet((s) => s.expandAllFragments());
    }
    trimUnsatisfiableBranches(_) {
        var _a;
        if (!this.selectionSet) {
            return this;
        }
        const base = (0, definitions_1.baseType)(this.element.definition.type);
        (0, utils_1.assert)((0, definitions_1.isCompositeType)(base), () => `Field ${this.element} should not have a sub-selection`);
        const trimmed = this.mapToSelectionSet((s) => s.trimUnsatisfiableBranches(base));
        if ((_a = trimmed.selectionSet) === null || _a === void 0 ? void 0 : _a.isEmpty()) {
            return trimmed.withUpdatedSelectionSet(selectionSetOfElement(new Field(base.typenameField(), undefined, [new definitions_1.Directive('include', { 'if': false })])));
        }
        else {
            return trimmed;
        }
    }
    expandFragments(names, updatedFragments) {
        return this.mapToSelectionSet((s) => s.expandFragments(names, updatedFragments));
    }
    equals(that) {
        if (this === that) {
            return true;
        }
        if (!(that instanceof FieldSelection) || !this.element.equals(that.element)) {
            return false;
        }
        if (!this.selectionSet) {
            return !that.selectionSet;
        }
        return !!that.selectionSet && this.selectionSet.equals(that.selectionSet);
    }
    contains(that) {
        if (!(that instanceof FieldSelection) || !this.element.equals(that.element)) {
            return false;
        }
        if (!that.selectionSet) {
            return true;
        }
        return !!this.selectionSet && this.selectionSet.contains(that.selectionSet);
    }
    isUnecessaryInlineFragment(_) {
        return false;
    }
    toString(expandFragments = true, indent) {
        return (indent !== null && indent !== void 0 ? indent : '') + this.element + (this.selectionSet ? ' ' + this.selectionSet.toString(expandFragments, true, indent) : '');
    }
}
exports.FieldSelection = FieldSelection;
class FragmentSelection extends AbstractSelection {
    constructor() {
        super(...arguments);
        this.kind = 'FragmentSelection';
    }
    us() {
        return this;
    }
    validateDeferAndStream() {
        if (this.element.hasDefer() || this.element.hasStream()) {
            const schemaDef = this.element.schema().schemaDefinition;
            const parentType = this.parentType;
            validate(schemaDef.rootType('mutation') !== parentType && schemaDef.rootType('subscription') !== parentType, () => { var _a; return `The @defer and @stream directives cannot be used on ${(_a = schemaDef.roots().filter((t) => t.type === parentType).pop()) === null || _a === void 0 ? void 0 : _a.rootKind} root type "${parentType}"`; });
        }
    }
    filter(predicate) {
        const selectionSet = this.selectionSet;
        const updatedSelectionSet = selectionSet.filter(predicate);
        const thisWithFilteredSelectionSet = updatedSelectionSet === selectionSet
            ? this
            : new InlineFragmentSelection(this.element, updatedSelectionSet);
        return predicate(thisWithFilteredSelectionSet) ? thisWithFilteredSelectionSet : undefined;
    }
    hasDefer() {
        return this.element.hasDefer() || this.selectionSet.hasDefer();
    }
    isUnecessaryInlineFragment(parentType) {
        return this.element.appliedDirectives.length === 0
            && !!this.element.typeCondition
            && (this.element.typeCondition.name === parentType.name
                || ((0, definitions_1.isObjectType)(parentType) && (0, definitions_1.possibleRuntimeTypes)(this.element.typeCondition).some((t) => t.name === parentType.name)));
    }
}
exports.FragmentSelection = FragmentSelection;
class InlineFragmentSelection extends FragmentSelection {
    constructor(fragment, _selectionSet) {
        super(fragment);
        this._selectionSet = _selectionSet;
    }
    get selectionSet() {
        return this._selectionSet;
    }
    key() {
        return this.element.key();
    }
    withUpdatedComponents(fragment, selectionSet) {
        return new InlineFragmentSelection(fragment, selectionSet);
    }
    validate(variableDefinitions) {
        this.validateDeferAndStream();
        validate(!this.selectionSet.isEmpty(), () => `Invalid empty selection set for fragment "${this.element}"`);
        this.selectionSet.validate(variableDefinitions);
    }
    rebaseOn(parentType) {
        if (this.parentType === parentType) {
            return this;
        }
        const rebasedFragment = this.element.rebaseOn(parentType);
        const rebasedCastedType = rebasedFragment.castedType();
        if (rebasedCastedType === this.selectionSet.parentType) {
            return this.withUpdatedElement(rebasedFragment);
        }
        return this.withUpdatedComponents(rebasedFragment, this.selectionSet.rebaseOn(rebasedCastedType));
    }
    canAddTo(parentType) {
        if (this.element.parentType === parentType) {
            return true;
        }
        const type = this.element.castedTypeIfAddedTo(parentType);
        if (!type) {
            return false;
        }
        if (this.selectionSet.parentType !== type) {
            return this.selectionSet.selections().every((s) => s.canAddTo(type));
        }
        return true;
    }
    toSelectionNode() {
        const typeCondition = this.element.typeCondition;
        return {
            kind: graphql_1.Kind.INLINE_FRAGMENT,
            typeCondition: typeCondition
                ? {
                    kind: graphql_1.Kind.NAMED_TYPE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: typeCondition.name,
                    },
                }
                : undefined,
            directives: this.element.appliedDirectivesToDirectiveNodes(),
            selectionSet: this.selectionSet.toSelectionSetNode()
        };
    }
    optimize(fragments) {
        let optimizedSelection = this.selectionSet.optimize(fragments);
        const typeCondition = this.element.typeCondition;
        if (typeCondition) {
            const optimized = this.tryOptimizeSubselectionWithFragments({
                parentType: typeCondition,
                subSelection: optimizedSelection,
                fragments,
            });
            if (optimized instanceof FragmentSpreadSelection) {
                return optimized;
            }
            optimizedSelection = optimized;
        }
        return this.selectionSet === optimizedSelection
            ? this
            : new InlineFragmentSelection(this.element, optimizedSelection);
    }
    tryOptimizeSubselectionOnce({ parentType, subSelection, candidates, fragments, }) {
        let optimizedSelection = subSelection;
        for (const candidate of candidates) {
            const { contains, diff } = optimizedSelection.diffIfContains(candidate.selectionSet);
            if (contains) {
                if (!diff && (0, types_1.sameType)(this.element.typeCondition, candidate.typeCondition)) {
                    let spreadDirectives = this.element.appliedDirectives;
                    if (candidate.appliedDirectives.length > 0) {
                        const { isSubset, difference } = diffDirectives(this.element.appliedDirectives, candidate.appliedDirectives);
                        if (!isSubset) {
                            continue;
                        }
                        spreadDirectives = difference;
                    }
                    return {
                        spread: new FragmentSpreadSelection(this.parentType, fragments, candidate, spreadDirectives),
                    };
                }
                if (candidate.appliedDirectives.length > 0) {
                    continue;
                }
                const spread = new FragmentSpreadSelection(parentType, fragments, candidate, []);
                optimizedSelection = diff
                    ? new SelectionSetUpdates().add(spread).add(diff).toSelectionSet(parentType, fragments)
                    : selectionSetOf(parentType, spread);
                return { spread, optimizedSelection, hasDiff: !!diff };
            }
        }
        return {};
    }
    withoutDefer(labelsToRemove) {
        const newSelection = this.selectionSet.withoutDefer(labelsToRemove);
        const deferArgs = this.element.deferDirectiveArgs();
        const hasDeferToRemove = deferArgs && (!labelsToRemove || (deferArgs.label && labelsToRemove.has(deferArgs.label)));
        if (newSelection === this.selectionSet && !hasDeferToRemove) {
            return this;
        }
        const newElement = hasDeferToRemove ? this.element.withoutDefer() : this.element;
        if (!newElement) {
            return newSelection;
        }
        return this.withUpdatedComponents(newElement, newSelection);
    }
    withNormalizedDefer(normalizer) {
        const newElement = this.element.withNormalizedDefer(normalizer);
        const newSelection = this.selectionSet.withNormalizedDefer(normalizer);
        if (!newElement) {
            return newSelection;
        }
        return newElement === this.element && newSelection === this.selectionSet
            ? this
            : this.withUpdatedComponents(newElement, newSelection);
    }
    trimUnsatisfiableBranches(currentType) {
        var _a, _b;
        const thisCondition = this.element.typeCondition;
        if (this.element.appliedDirectives.length === 0) {
            if (!thisCondition || currentType === this.element.typeCondition) {
                const trimmed = this.selectionSet.trimUnsatisfiableBranches(currentType);
                return trimmed.isEmpty() ? undefined : trimmed;
            }
            if ((0, definitions_1.isObjectType)(currentType)) {
                if ((0, definitions_1.isObjectType)(thisCondition) || !(0, definitions_1.possibleRuntimeTypes)(thisCondition).includes(currentType)) {
                    return undefined;
                }
                else {
                    const trimmed = this.selectionSet.trimUnsatisfiableBranches(currentType);
                    return trimmed.isEmpty() ? undefined : trimmed;
                }
            }
        }
        const trimmedSelectionSet = this.selectionSet.trimUnsatisfiableBranches((_a = this.element.typeCondition) !== null && _a !== void 0 ? _a : this.parentType);
        if (trimmedSelectionSet.isEmpty()) {
            if (this.element.appliedDirectives.length === 0) {
                return undefined;
            }
            else {
                return this.withUpdatedSelectionSet(selectionSetOfElement(new Field(((_b = this.element.typeCondition) !== null && _b !== void 0 ? _b : this.parentType).typenameField(), undefined, [new definitions_1.Directive('include', { 'if': false })])));
            }
        }
        if (this.element.appliedDirectives.length === 0 && (0, definitions_1.isAbstractType)(thisCondition)) {
            (0, utils_1.assert)(!(0, definitions_1.isObjectType)(currentType), () => `Should not have got here if ${currentType} is an object type`);
            const currentRuntimes = (0, definitions_1.possibleRuntimeTypes)(currentType);
            const liftableSelections = [];
            for (const selection of trimmedSelectionSet.selections()) {
                if (selection.kind === 'FragmentSelection'
                    && selection.element.typeCondition
                    && (0, definitions_1.isObjectType)(selection.element.typeCondition)
                    && currentRuntimes.includes(selection.element.typeCondition)) {
                    liftableSelections.push(selection);
                }
            }
            if (liftableSelections.length === trimmedSelectionSet.selections().length) {
                return trimmedSelectionSet;
            }
            if (liftableSelections.length > 0) {
                const newSet = new SelectionSetUpdates();
                newSet.add(liftableSelections);
                newSet.add(this.withUpdatedSelectionSet(trimmedSelectionSet.filter((s) => !liftableSelections.includes(s))));
                return newSet.toSelectionSet(this.parentType);
            }
        }
        return this.selectionSet === trimmedSelectionSet ? this : this.withUpdatedSelectionSet(trimmedSelectionSet);
    }
    expandAllFragments() {
        return this.mapToSelectionSet((s) => s.expandAllFragments());
    }
    expandFragments(names, updatedFragments) {
        return this.mapToSelectionSet((s) => s.expandFragments(names, updatedFragments));
    }
    equals(that) {
        if (this === that) {
            return true;
        }
        return (that instanceof FragmentSelection)
            && this.element.equals(that.element)
            && this.selectionSet.equals(that.selectionSet);
    }
    contains(that) {
        return (that instanceof FragmentSelection)
            && this.element.equals(that.element)
            && this.selectionSet.contains(that.selectionSet);
    }
    toString(expandFragments = true, indent) {
        return (indent !== null && indent !== void 0 ? indent : '') + this.element + ' ' + this.selectionSet.toString(expandFragments, true, indent);
    }
}
function diffDirectives(superset, maybeSubset) {
    if (maybeSubset.every((d) => superset.some((s) => (0, definitions_1.sameDirectiveApplication)(d, s)))) {
        return { isSubset: true, difference: superset.filter((s) => !maybeSubset.some((d) => (0, definitions_1.sameDirectiveApplication)(d, s))) };
    }
    else {
        return { isSubset: false, difference: [] };
    }
}
class FragmentSpreadSelection extends FragmentSelection {
    constructor(sourceType, fragments, namedFragment, spreadDirectives) {
        super(new FragmentElement(sourceType, namedFragment.typeCondition, namedFragment.appliedDirectives.concat(spreadDirectives)));
        this.fragments = fragments;
        this.namedFragment = namedFragment;
        this.spreadDirectives = spreadDirectives;
    }
    get selectionSet() {
        return this.namedFragment.selectionSet;
    }
    key() {
        if (!this.computedKey) {
            this.computedKey = '...' + this.namedFragment.name + (this.spreadDirectives.length === 0 ? '' : ' ' + this.spreadDirectives.join(' '));
        }
        return this.computedKey;
    }
    withUpdatedComponents(_fragment, _selectionSet) {
        (0, utils_1.assert)(false, `Unsupported`);
    }
    trimUnsatisfiableBranches(_) {
        return this;
    }
    namedFragments() {
        return this.fragments;
    }
    validate() {
        this.validateDeferAndStream();
    }
    toSelectionNode() {
        const directiveNodes = this.spreadDirectives.length === 0
            ? undefined
            : this.spreadDirectives.map(directive => {
                return {
                    kind: graphql_1.Kind.DIRECTIVE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: directive.name,
                    },
                    arguments: directive.argumentsToAST()
                };
            });
        return {
            kind: graphql_1.Kind.FRAGMENT_SPREAD,
            name: { kind: graphql_1.Kind.NAME, value: this.namedFragment.name },
            directives: directiveNodes,
        };
    }
    optimize(_) {
        return this;
    }
    rebaseOn(_parentType) {
        return this;
    }
    canAddTo(_) {
        return true;
    }
    expandAllFragments() {
        const expandedSubSelections = this.selectionSet.expandAllFragments();
        return (0, types_1.sameType)(this.parentType, this.namedFragment.typeCondition) && this.element.appliedDirectives.length === 0
            ? expandedSubSelections.selections()
            : new InlineFragmentSelection(this.element, expandedSubSelections);
    }
    expandFragments(names, updatedFragments) {
        if (!names.includes(this.namedFragment.name)) {
            return this;
        }
        const expandedSubSelections = this.selectionSet.expandFragments(names, updatedFragments);
        return (0, types_1.sameType)(this.parentType, this.namedFragment.typeCondition) && this.element.appliedDirectives.length === 0
            ? expandedSubSelections.selections()
            : new InlineFragmentSelection(this.element, expandedSubSelections);
    }
    collectUsedFragmentNames(collector) {
        this.selectionSet.collectUsedFragmentNames(collector);
        const usageCount = collector.get(this.namedFragment.name);
        collector.set(this.namedFragment.name, usageCount === undefined ? 1 : usageCount + 1);
    }
    withoutDefer(_labelsToRemove) {
        (0, utils_1.assert)(false, 'Unsupported, see `Operation.withAllDeferLabelled`');
    }
    withNormalizedDefer(_normalizer) {
        (0, utils_1.assert)(false, 'Unsupported, see `Operation.withAllDeferLabelled`');
    }
    minus(that) {
        (0, utils_1.assert)(this.equals(that), () => `Invalid operation for ${this.toString(false)} and ${that.toString(false)}`);
        return undefined;
    }
    equals(that) {
        if (this === that) {
            return true;
        }
        return (that instanceof FragmentSpreadSelection)
            && this.namedFragment.name === that.namedFragment.name
            && (0, definitions_1.sameDirectiveApplications)(this.spreadDirectives, that.spreadDirectives);
    }
    contains(that) {
        if (this.equals(that)) {
            return true;
        }
        return (that instanceof FragmentSelection)
            && this.element.equals(that.element)
            && this.selectionSet.contains(that.selectionSet);
    }
    toString(expandFragments = true, indent) {
        if (expandFragments) {
            return (indent !== null && indent !== void 0 ? indent : '') + this.element + ' ' + this.selectionSet.toString(true, true, indent);
        }
        else {
            const directives = this.spreadDirectives;
            const directiveString = directives.length == 0 ? '' : ' ' + directives.join(' ');
            return (indent !== null && indent !== void 0 ? indent : '') + '...' + this.namedFragment.name + directiveString;
        }
    }
}
function selectionSetOfNode(parentType, node, variableDefinitions, fragments, fieldAccessor = (type, name) => type.field(name)) {
    if (node.selections.length === 1) {
        return selectionSetOf(parentType, selectionOfNode(parentType, node.selections[0], variableDefinitions, fragments, fieldAccessor), fragments);
    }
    const selections = new SelectionSetUpdates();
    for (const selectionNode of node.selections) {
        selections.add(selectionOfNode(parentType, selectionNode, variableDefinitions, fragments, fieldAccessor));
    }
    return selections.toSelectionSet(parentType, fragments);
}
function directiveOfNode(schema, node) {
    const directiveDef = schema.directive(node.name.value);
    validate(directiveDef, () => `Unknown directive "@${node.name.value}"`);
    return new definitions_1.Directive(directiveDef.name, (0, values_1.argumentsFromAST)(directiveDef.coordinate, node.arguments, directiveDef));
}
function directivesOfNodes(schema, nodes) {
    var _a;
    return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((n) => directiveOfNode(schema, n))) !== null && _a !== void 0 ? _a : [];
}
function selectionOfNode(parentType, node, variableDefinitions, fragments, fieldAccessor = (type, name) => type.field(name)) {
    var _a, _b;
    let selection;
    const directives = directivesOfNodes(parentType.schema(), node.directives);
    switch (node.kind) {
        case graphql_1.Kind.FIELD:
            const definition = fieldAccessor(parentType, node.name.value);
            validate(definition, () => `Cannot query field "${node.name.value}" on type "${parentType}".`, parentType.sourceAST);
            const type = (0, definitions_1.baseType)(definition.type);
            const selectionSet = node.selectionSet
                ? selectionSetOfNode(type, node.selectionSet, variableDefinitions, fragments, fieldAccessor)
                : undefined;
            selection = new FieldSelection(new Field(definition, (0, values_1.argumentsFromAST)(definition.coordinate, node.arguments, definition), directives, (_a = node.alias) === null || _a === void 0 ? void 0 : _a.value), selectionSet);
            break;
        case graphql_1.Kind.INLINE_FRAGMENT:
            const element = new FragmentElement(parentType, (_b = node.typeCondition) === null || _b === void 0 ? void 0 : _b.name.value, directives);
            selection = new InlineFragmentSelection(element, selectionSetOfNode(element.typeCondition ? element.typeCondition : element.parentType, node.selectionSet, variableDefinitions, fragments, fieldAccessor));
            break;
        case graphql_1.Kind.FRAGMENT_SPREAD:
            const fragmentName = node.name.value;
            validate(fragments, () => `Cannot find fragment name "${fragmentName}" (no fragments were provided)`);
            const fragment = fragments.get(fragmentName);
            validate(fragment, () => `Cannot find fragment name "${fragmentName}" (provided fragments are: [${fragments.names().join(', ')}])`);
            selection = new FragmentSpreadSelection(parentType, fragments, fragment, directives);
            break;
    }
    return selection;
}
function operationFromDocument(schema, document, options) {
    let operation;
    const operationName = options === null || options === void 0 ? void 0 : options.operationName;
    const fragments = new NamedFragments();
    document.definitions.forEach(definition => {
        switch (definition.kind) {
            case graphql_1.Kind.OPERATION_DEFINITION:
                validate(!operation || operationName, () => 'Must provide operation name if query contains multiple operations.');
                if (!operationName || (definition.name && definition.name.value === operationName)) {
                    operation = definition;
                }
                break;
            case graphql_1.Kind.FRAGMENT_DEFINITION:
                const name = definition.name.value;
                const typeName = definition.typeCondition.name.value;
                const typeCondition = schema.type(typeName);
                if (!typeCondition) {
                    throw error_1.ERRORS.INVALID_GRAPHQL.err(`Unknown type "${typeName}" for fragment "${name}"`, { nodes: definition });
                }
                if (!(0, definitions_1.isCompositeType)(typeCondition)) {
                    throw error_1.ERRORS.INVALID_GRAPHQL.err(`Invalid fragment "${name}" on non-composite type "${typeName}"`, { nodes: definition });
                }
                fragments.add(new NamedFragmentDefinition(schema, name, typeCondition, directivesOfNodes(schema, definition.directives)));
                break;
        }
    });
    validate(operation, () => operationName ? `Unknown operation named "${operationName}"` : 'No operation found in provided document.');
    const variableDefinitions = operation.variableDefinitions
        ? (0, definitions_1.variableDefinitionsFromAST)(schema, operation.variableDefinitions)
        : new definitions_1.VariableDefinitions();
    document.definitions.forEach(definition => {
        switch (definition.kind) {
            case graphql_1.Kind.FRAGMENT_DEFINITION:
                const fragment = fragments.get(definition.name.value);
                fragment.setSelectionSet(selectionSetOfNode(fragment.typeCondition, definition.selectionSet, variableDefinitions, fragments));
                break;
        }
    });
    fragments.validate(variableDefinitions);
    return operationFromAST({ schema, operation, variableDefinitions, fragments, validateInput: options === null || options === void 0 ? void 0 : options.validate });
}
exports.operationFromDocument = operationFromDocument;
function operationFromAST({ schema, operation, variableDefinitions, fragments, validateInput, }) {
    var _a;
    const rootType = schema.schemaDefinition.root(operation.operation);
    validate(rootType, () => `The schema has no "${operation.operation}" root type defined`);
    return new Operation(schema, operation.operation, parseSelectionSet({
        parentType: rootType.type,
        source: operation.selectionSet,
        variableDefinitions,
        fragments: fragments.isEmpty() ? undefined : fragments,
        validate: validateInput,
    }), variableDefinitions, (_a = operation.name) === null || _a === void 0 ? void 0 : _a.value);
}
function parseOperation(schema, operation, options) {
    return operationFromDocument(schema, (0, graphql_1.parse)(operation), options);
}
exports.parseOperation = parseOperation;
function parseSelectionSet({ parentType, source, variableDefinitions = new definitions_1.VariableDefinitions(), fragments, fieldAccessor, validate = true, }) {
    const node = typeof source === 'string'
        ? parseOperationAST(source.trim().startsWith('{') ? source : `{${source}}`).selectionSet
        : source;
    const selectionSet = selectionSetOfNode(parentType, node, variableDefinitions !== null && variableDefinitions !== void 0 ? variableDefinitions : new definitions_1.VariableDefinitions(), fragments, fieldAccessor);
    if (validate)
        selectionSet.validate(variableDefinitions);
    return selectionSet;
}
exports.parseSelectionSet = parseSelectionSet;
function parseOperationAST(source) {
    const parsed = (0, graphql_1.parse)(source);
    validate(parsed.definitions.length === 1, () => 'Selections should contain a single definitions, found ' + parsed.definitions.length);
    const def = parsed.definitions[0];
    validate(def.kind === graphql_1.Kind.OPERATION_DEFINITION, () => 'Expected an operation definition but got a ' + def.kind);
    return def;
}
function operationToDocument(operation) {
    var _a;
    const operationAST = {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: operation.rootKind,
        name: operation.name ? { kind: graphql_1.Kind.NAME, value: operation.name } : undefined,
        selectionSet: operation.selectionSet.toSelectionSetNode(),
        variableDefinitions: operation.variableDefinitions.toVariableDefinitionNodes(),
    };
    const fragmentASTs = operation.selectionSet.fragments
        ? (_a = operation.selectionSet.fragments) === null || _a === void 0 ? void 0 : _a.toFragmentDefinitionNodes()
        : [];
    return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [operationAST].concat(fragmentASTs),
    };
}
exports.operationToDocument = operationToDocument;
//# sourceMappingURL=operations.js.map