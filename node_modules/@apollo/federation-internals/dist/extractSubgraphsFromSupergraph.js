"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSubgraphsFromSupergraph = exports.extractSubgraphsNamesAndUrlsFromSupergraph = void 0;
const definitions_1 = require("./definitions");
const federation_1 = require("./federation");
const coreSpec_1 = require("./coreSpec");
const federation_2 = require("./federation");
const utils_1 = require("./utils");
const supergraphs_1 = require("./supergraphs");
const buildSchema_1 = require("./buildSchema");
const types_1 = require("./types");
const print_1 = require("./print");
const operations_1 = require("./operations");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const utils_2 = require("./utils");
const _1 = require(".");
function filteredTypes(supergraph, joinSpec, coreSpec) {
    return supergraph.types().filter(t => !joinSpec.isSpecType(t) && !coreSpec.isSpecType(t));
}
function extractSubgraphsNamesAndUrlsFromSupergraph(supergraph) {
    const [_, joinSpec] = (0, supergraphs_1.validateSupergraph)(supergraph);
    const [subgraphs] = collectEmptySubgraphs(supergraph, joinSpec);
    return subgraphs.values().map(subgraph => { return { name: subgraph.name, url: subgraph.url }; });
}
exports.extractSubgraphsNamesAndUrlsFromSupergraph = extractSubgraphsNamesAndUrlsFromSupergraph;
function collectEmptySubgraphs(supergraph, joinSpec) {
    const subgraphs = new federation_2.Subgraphs();
    const graphDirective = joinSpec.graphDirective(supergraph);
    const graphEnum = joinSpec.graphEnum(supergraph);
    const graphEnumNameToSubgraphName = new Map();
    for (const value of graphEnum.values) {
        const graphApplications = value.appliedDirectivesOf(graphDirective);
        if (!graphApplications.length) {
            throw new Error(`Value ${value} of join__Graph enum has no @join__graph directive`);
        }
        const info = graphApplications[0].arguments();
        const subgraph = new federation_2.Subgraph(info.name, info.url, (0, federation_1.newEmptyFederation2Schema)());
        subgraphs.add(subgraph);
        graphEnumNameToSubgraphName.set(value.name, info.name);
    }
    return [subgraphs, graphEnumNameToSubgraphName];
}
class SubgraphExtractionError {
    constructor(originalError, subgraph) {
        this.originalError = originalError;
        this.subgraph = subgraph;
    }
}
function collectFieldReachableTypesForSubgraph(supergraph, subgraphName, addReachableType, fieldInfoInSubgraph, typeInfoInSubgraph) {
    const seenTypes = new Set();
    const stack = supergraph.schemaDefinition.roots().map((root) => root.type);
    for (const type of supergraph.types()) {
        const { isEntityWithKeyInSubgraph, typesInFederationDirectives } = typeInfoInSubgraph(type, subgraphName);
        if (isEntityWithKeyInSubgraph) {
            stack.push(type);
        }
        typesInFederationDirectives.forEach((t) => stack.push(t));
    }
    while (stack.length > 0) {
        const type = stack.pop();
        addReachableType(type);
        if (seenTypes.has(type.name)) {
            continue;
        }
        seenTypes.add(type.name);
        switch (type.kind) {
            case 'InterfaceType':
                type.allImplementations().forEach((t) => stack.push(t));
            case 'ObjectType':
                type.interfaces().forEach((t) => stack.push(t));
                for (const field of type.fields()) {
                    const { isInSubgraph, typesInFederationDirectives } = fieldInfoInSubgraph(field, subgraphName);
                    if (isInSubgraph) {
                        field.arguments().forEach((arg) => stack.push((0, definitions_1.baseType)(arg.type)));
                        stack.push((0, definitions_1.baseType)(field.type));
                        typesInFederationDirectives.forEach((t) => stack.push(t));
                    }
                }
                break;
            case 'InputObjectType':
                for (const field of type.fields()) {
                    const { isInSubgraph, typesInFederationDirectives } = fieldInfoInSubgraph(field, subgraphName);
                    if (isInSubgraph) {
                        stack.push((0, definitions_1.baseType)(field.type));
                        typesInFederationDirectives.forEach((t) => stack.push(t));
                    }
                }
                break;
            case 'UnionType':
                type.members().forEach((m) => stack.push(m.type));
                break;
        }
    }
    for (const directive of supergraph.directives()) {
        if (!directive.hasExecutableLocations()) {
            continue;
        }
        directive.arguments().forEach((arg) => stack.push((0, definitions_1.baseType)(arg.type)));
    }
}
function collectFieldReachableTypesForAllSubgraphs(supergraph, allSubgraphs, fieldInfoInSubgraph, typeInfoInSubgraph) {
    const reachableTypesBySubgraphs = new Map();
    for (const subgraphName of allSubgraphs) {
        const reachableTypes = new Set();
        collectFieldReachableTypesForSubgraph(supergraph, subgraphName, (t) => reachableTypes.add(t.name), fieldInfoInSubgraph, typeInfoInSubgraph);
        reachableTypesBySubgraphs.set(subgraphName, reachableTypes);
    }
    return reachableTypesBySubgraphs;
}
function typesUsedInFederationDirective(fieldSet, parentType) {
    if (!fieldSet) {
        return [];
    }
    const usedTypes = [];
    (0, operations_1.parseSelectionSet)({
        parentType,
        source: fieldSet,
        fieldAccessor: (type, fieldName) => {
            const field = type.field(fieldName);
            if (field) {
                usedTypes.push((0, definitions_1.baseType)(field.type));
            }
            return field;
        },
        validate: false,
    });
    return usedTypes;
}
function extractSubgraphsFromSupergraph(supergraph) {
    const [coreFeatures, joinSpec] = (0, supergraphs_1.validateSupergraph)(supergraph);
    const isFed1 = joinSpec.version.equals(new coreSpec_1.FeatureVersion(0, 1));
    try {
        const [subgraphs, graphEnumNameToSubgraphName] = collectEmptySubgraphs(supergraph, joinSpec);
        const typeDirective = joinSpec.typeDirective(supergraph);
        const implementsDirective = joinSpec.implementsDirective(supergraph);
        const ownerDirective = joinSpec.ownerDirective(supergraph);
        const fieldDirective = joinSpec.fieldDirective(supergraph);
        const unionMemberDirective = joinSpec.unionMemberDirective(supergraph);
        const enumValueDirective = joinSpec.enumValueDirective(supergraph);
        const getSubgraph = (application) => {
            const graph = application.arguments().graph;
            return graph ? graphEnumNameToSubgraphName.get(graph) : undefined;
        };
        let includeTypeInSubgraph = () => true;
        if (isFed1) {
            const reachableTypesBySubgraph = collectFieldReachableTypesForAllSubgraphs(supergraph, subgraphs.names(), (f, name) => {
                const fieldApplications = f.appliedDirectivesOf(fieldDirective);
                if (fieldApplications.length) {
                    const application = fieldApplications.find((application) => getSubgraph(application) === name);
                    if (application) {
                        const args = application.arguments();
                        const typesInFederationDirectives = typesUsedInFederationDirective(args.provides, (0, definitions_1.baseType)(f.type))
                            .concat(typesUsedInFederationDirective(args.requires, f.parent));
                        return { isInSubgraph: true, typesInFederationDirectives };
                    }
                    else {
                        return { isInSubgraph: false, typesInFederationDirectives: [] };
                    }
                }
                else {
                    const ownerApplications = ownerDirective ? f.parent.appliedDirectivesOf(ownerDirective) : [];
                    return { isInSubgraph: !ownerApplications.length || getSubgraph(ownerApplications[0]) == name, typesInFederationDirectives: [] };
                }
            }, (t, name) => {
                const typeApplications = t.appliedDirectivesOf(typeDirective);
                const application = typeApplications.find((application) => (application.arguments().key && (getSubgraph(application) === name)));
                if (application) {
                    const typesInFederationDirectives = typesUsedInFederationDirective(application.arguments().key, t);
                    return { isEntityWithKeyInSubgraph: true, typesInFederationDirectives };
                }
                else {
                    return { isEntityWithKeyInSubgraph: false, typesInFederationDirectives: [] };
                }
            });
            includeTypeInSubgraph = (t, name) => { var _a, _b; return (_b = (_a = reachableTypesBySubgraph.get(name)) === null || _a === void 0 ? void 0 : _a.has(t.name)) !== null && _b !== void 0 ? _b : false; };
        }
        for (const type of filteredTypes(supergraph, joinSpec, coreFeatures.coreDefinition)) {
            const typeApplications = type.appliedDirectivesOf(typeDirective);
            if (!typeApplications.length) {
                subgraphs
                    .values()
                    .filter((sg) => includeTypeInSubgraph(type, sg.name))
                    .map(sg => sg.schema).forEach(schema => schema.addType((0, definitions_1.newNamedType)(type.kind, type.name)));
            }
            else {
                for (const application of typeApplications) {
                    const args = application.arguments();
                    const subgraphName = getSubgraph(application);
                    const schema = subgraphs.get(subgraphName).schema;
                    let subgraphType = schema.type(type.name);
                    if (!subgraphType) {
                        const kind = args.isInterfaceObject ? 'ObjectType' : type.kind;
                        subgraphType = schema.addType((0, definitions_1.newNamedType)(kind, type.name));
                        if (args.isInterfaceObject) {
                            subgraphType.applyDirective('interfaceObject');
                        }
                    }
                    if (args.key) {
                        const { resolvable } = args;
                        const directive = subgraphType.applyDirective('key', { 'fields': args.key, resolvable });
                        if (args.extension) {
                            directive.setOfExtension(subgraphType.newExtension());
                        }
                    }
                }
            }
        }
        for (const type of filteredTypes(supergraph, joinSpec, coreFeatures.coreDefinition)) {
            switch (type.kind) {
                case 'ObjectType':
                case 'InterfaceType':
                    const addedInterfaces = [];
                    const implementsApplications = implementsDirective ? type.appliedDirectivesOf(implementsDirective) : [];
                    for (const application of implementsApplications) {
                        const args = application.arguments();
                        const subgraph = subgraphs.get(graphEnumNameToSubgraphName.get(args.graph));
                        const schema = subgraph.schema;
                        schema.type(type.name).addImplementedInterface(args.interface);
                        addedInterfaces.push(args.interface);
                    }
                    for (const implementations of type.interfaceImplementations()) {
                        const name = implementations.interface.name;
                        if (!addedInterfaces.includes(name)) {
                            for (const subgraph of subgraphs) {
                                const subgraphType = subgraph.schema.type(type.name);
                                const subgraphItf = subgraph.schema.type(name);
                                if (subgraphType && subgraphItf) {
                                    subgraphType.addImplementedInterface(name);
                                }
                            }
                        }
                    }
                case 'InputObjectType':
                    for (const field of type.fields()) {
                        const fieldApplications = field.appliedDirectivesOf(fieldDirective);
                        if (!fieldApplications.length) {
                            const ownerApplications = ownerDirective ? type.appliedDirectivesOf(ownerDirective) : [];
                            if (!ownerApplications.length) {
                                const fieldBaseType = (0, definitions_1.baseType)(field.type);
                                const isShareable = (0, definitions_1.isObjectType)(type) && subgraphs.values().filter((s) => s.schema.type(type.name)).length > 1;
                                for (const subgraph of subgraphs) {
                                    if (subgraph.schema.type(fieldBaseType.name)) {
                                        const subgraphField = addSubgraphField(field, subgraph);
                                        if (subgraphField && isShareable) {
                                            subgraphField.applyDirective(subgraph.metadata().shareableDirective());
                                        }
                                    }
                                }
                            }
                            else {
                                (0, utils_1.assert)(ownerApplications.length == 1, () => `Found multiple join__owner directives on type ${type}`);
                                const subgraph = subgraphs.get(graphEnumNameToSubgraphName.get(ownerApplications[0].arguments().graph));
                                const subgraphField = addSubgraphField(field, subgraph);
                                (0, utils_1.assert)(subgraphField, () => `Found join__owner directive on ${type} but no corresponding join__type`);
                            }
                        }
                        else {
                            const isShareable = (0, definitions_1.isObjectType)(type)
                                && fieldApplications.filter((application) => {
                                    const args = application.arguments();
                                    return !args.external && !args.usedOverridden;
                                }).length > 1;
                            for (const application of fieldApplications) {
                                const args = application.arguments();
                                if (!args.graph) {
                                    continue;
                                }
                                const subgraph = subgraphs.get(graphEnumNameToSubgraphName.get(args.graph));
                                const subgraphField = addSubgraphField(field, subgraph, args.type);
                                if (!subgraphField) {
                                    (0, utils_1.assert)(!includeTypeInSubgraph(type, subgraph.name), () => `Found join__field directive for graph ${subgraph.name} on field ${field.coordinate} but no corresponding join__type on ${type}`);
                                    continue;
                                }
                                if (args.requires) {
                                    subgraphField.applyDirective(subgraph.metadata().requiresDirective(), { 'fields': args.requires });
                                }
                                if (args.provides) {
                                    subgraphField.applyDirective(subgraph.metadata().providesDirective(), { 'fields': args.provides });
                                }
                                if (args.external) {
                                    subgraphField.applyDirective(subgraph.metadata().externalDirective());
                                }
                                if (args.usedOverridden) {
                                    subgraphField.applyDirective(subgraph.metadata().externalDirective(), { 'reason': '[overridden]' });
                                }
                                if (args.override) {
                                    subgraphField.applyDirective(subgraph.metadata().overrideDirective(), { 'from': args.override });
                                }
                                if (isShareable && !args.external && !args.usedOverridden) {
                                    subgraphField.applyDirective(subgraph.metadata().shareableDirective());
                                }
                            }
                        }
                    }
                    break;
                case 'EnumType':
                    for (const subgraph of subgraphs) {
                        const subgraphEnum = subgraph.schema.type(type.name);
                        if (!subgraphEnum) {
                            continue;
                        }
                        (0, utils_1.assert)((0, definitions_1.isEnumType)(subgraphEnum), () => `${subgraphEnum} should be an enum but found a ${subgraphEnum.kind}`);
                        for (const value of type.values) {
                            const addValue = !enumValueDirective
                                || value.appliedDirectivesOf(enumValueDirective).some((d) => graphEnumNameToSubgraphName.get(d.arguments().graph) === subgraph.name);
                            if (addValue) {
                                subgraphEnum.addValue(value.name);
                            }
                        }
                    }
                    break;
                case 'UnionType':
                    for (const subgraph of subgraphs) {
                        const subgraphUnion = subgraph.schema.type(type.name);
                        if (!subgraphUnion) {
                            continue;
                        }
                        (0, utils_1.assert)((0, definitions_1.isUnionType)(subgraphUnion), () => `${subgraphUnion} should be an enum but found a ${subgraphUnion.kind}`);
                        let membersInSubgraph;
                        if (unionMemberDirective) {
                            membersInSubgraph = type
                                .appliedDirectivesOf(unionMemberDirective)
                                .filter((d) => graphEnumNameToSubgraphName.get(d.arguments().graph) === subgraph.name)
                                .map((d) => d.arguments().member);
                        }
                        else {
                            membersInSubgraph = type.types().map((t) => t.name);
                        }
                        for (const memberTypeName of membersInSubgraph) {
                            const subgraphType = subgraph.schema.type(memberTypeName);
                            if (subgraphType) {
                                subgraphUnion.addType(subgraphType);
                            }
                        }
                    }
                    break;
            }
        }
        const allExecutableDirectives = supergraph.directives().filter((def) => def.hasExecutableLocations());
        for (const subgraph of subgraphs) {
            if (isFed1) {
                addExternalFields(subgraph, supergraph, isFed1);
            }
            (0, federation_1.removeInactiveProvidesAndRequires)(subgraph.schema);
            for (const type of subgraph.schema.types()) {
                switch (type.kind) {
                    case 'ObjectType':
                    case 'InterfaceType':
                    case 'InputObjectType':
                        if (!type.hasFields()) {
                            type.removeRecursive();
                        }
                        break;
                    case 'UnionType':
                        if (type.membersCount() === 0) {
                            type.removeRecursive();
                        }
                        break;
                }
            }
            for (const definition of allExecutableDirectives) {
                (0, definitions_1.copyDirectiveDefinitionToSchema)({
                    definition,
                    schema: subgraph.schema,
                    copyDirectiveApplicationsInArguments: false,
                    locationFilter: (loc) => (0, definitions_1.isExecutableDirectiveLocation)(loc),
                });
            }
        }
        if (isFed1) {
            for (const subgraph of subgraphs) {
                for (const itf of subgraph.schema.interfaceTypes()) {
                    const implementations = itf.possibleRuntimeTypes();
                    for (const field of itf.fields()) {
                        if (!implementations.every(implem => implem.field(field.name))) {
                            field.remove();
                        }
                    }
                    if (!itf.hasFields()) {
                        itf.remove();
                    }
                }
            }
        }
        for (const subgraph of subgraphs) {
            try {
                subgraph.validate();
            }
            catch (e) {
                throw new SubgraphExtractionError(e, subgraph);
            }
        }
        return subgraphs;
    }
    catch (e) {
        let error = e;
        let subgraph = undefined;
        if (e instanceof SubgraphExtractionError) {
            error = e.originalError;
            subgraph = e.subgraph;
        }
        const impacted = subgraph ? `subgraph "${subgraph.name}"` : 'subgraphs';
        if (isFed1) {
            const msg = `Error extracting ${impacted} from the supergraph: this might be due to errors in subgraphs that were mistakenly ignored by federation 0.x versions but are rejected by federation 2.\n`
                + 'Please try composing your subgraphs with federation 2: this should help precisely pinpoint the problems and, once fixed, generate a correct federation 2 supergraph';
            throw new Error(`${msg}.\n\nDetails:\n${errorToString(error)}`);
        }
        else {
            const msg = `Unexpected error extracting ${impacted} from the supergraph: this is either a bug, or the supergraph has been corrupted`;
            const dumpMsg = subgraph ? '\n\n' + maybeDumpSubgraphSchema(subgraph) : '';
            throw new Error(`${msg}.\n\nDetails:\n${errorToString(error)}${dumpMsg}`);
        }
    }
}
exports.extractSubgraphsFromSupergraph = extractSubgraphsFromSupergraph;
const DEBUG_SUBGRAPHS_ENV_VARIABLE_NAME = 'APOLLO_FEDERATION_DEBUG_SUBGRAPHS';
function maybeDumpSubgraphSchema(subgraph) {
    const shouldDump = !!(0, utils_2.validateStringContainsBoolean)(process.env[DEBUG_SUBGRAPHS_ENV_VARIABLE_NAME]);
    if (!shouldDump) {
        return `Re-run with environment variable '${DEBUG_SUBGRAPHS_ENV_VARIABLE_NAME}' set to 'true' to extract the invalid subgraph`;
    }
    try {
        const filename = `extracted-subgraph-${subgraph.name}-${Date.now()}.graphql`;
        const file = path_1.default.resolve(filename);
        if (fs_1.default.existsSync(file)) {
            throw new Error(`candidate file ${filename} already existed`);
        }
        fs_1.default.writeFileSync(file, (0, print_1.printSchema)(subgraph.schema));
        return `The (invalid) extracted subgraph has been written in: ${file}.`;
    }
    catch (e2) {
        return `Was not able to print generated subgraph for "${subgraph.name}" because: ${errorToString(e2)}`;
    }
}
function errorToString(e) {
    const causes = (0, _1.errorCauses)(e);
    return causes ? (0, _1.printErrors)(causes) : String(e);
}
function addSubgraphField(supergraphField, subgraph, encodedType) {
    if (supergraphField instanceof definitions_1.FieldDefinition) {
        return addSubgraphObjectOrInterfaceField(supergraphField, subgraph, encodedType);
    }
    else {
        return addSubgraphInputField(supergraphField, subgraph, encodedType);
    }
}
function addSubgraphObjectOrInterfaceField(supergraphField, subgraph, encodedType) {
    const subgraphType = subgraph.schema.type(supergraphField.parent.name);
    if (subgraphType) {
        const copiedType = encodedType
            ? decodeType(encodedType, subgraph.schema, subgraph.name)
            : copyType(supergraphField.type, subgraph.schema, subgraph.name);
        const field = subgraphType.addField(supergraphField.name, copiedType);
        for (const arg of supergraphField.arguments()) {
            field.addArgument(arg.name, copyType(arg.type, subgraph.schema, subgraph.name), arg.defaultValue);
        }
        return field;
    }
    else {
        return undefined;
    }
}
function addSubgraphInputField(supergraphField, subgraph, encodedType) {
    const subgraphType = subgraph.schema.type(supergraphField.parent.name);
    if (subgraphType) {
        const copiedType = encodedType
            ? decodeType(encodedType, subgraph.schema, subgraph.name)
            : copyType(supergraphField.type, subgraph.schema, subgraph.name);
        const field = subgraphType.addField(supergraphField.name, copiedType);
        field.defaultValue = supergraphField.defaultValue;
        return field;
    }
    else {
        return undefined;
    }
}
function decodeType(encodedType, subgraph, subgraphName) {
    try {
        return (0, buildSchema_1.builtTypeReference)(encodedType, subgraph);
    }
    catch (e) {
        (0, utils_1.assert)(false, () => `Cannot parse type "${encodedType}" in subgraph ${subgraphName}: ${e}`);
    }
}
function copyType(type, subgraph, subgraphName) {
    switch (type.kind) {
        case 'ListType':
            return new definitions_1.ListType(copyType(type.ofType, subgraph, subgraphName));
        case 'NonNullType':
            return new definitions_1.NonNullType(copyType(type.ofType, subgraph, subgraphName));
        default:
            const subgraphType = subgraph.type(type.name);
            (0, utils_1.assert)(subgraphType, () => `Cannot find type "${type.name}" in subgraph "${subgraphName}"`);
            return subgraphType;
    }
}
function addExternalFields(subgraph, supergraph, isFed1) {
    const metadata = subgraph.metadata();
    for (const type of subgraph.schema.types()) {
        if (!(0, definitions_1.isObjectType)(type) && !(0, definitions_1.isInterfaceType)(type)) {
            continue;
        }
        for (const keyApplication of type.appliedDirectivesOf(metadata.keyDirective())) {
            const forceNonExternal = isFed1 || !!keyApplication.ofExtension();
            addExternalFieldsFromDirectiveFieldSet(subgraph, type, keyApplication, supergraph, forceNonExternal);
        }
        for (const field of type.fields()) {
            for (const requiresApplication of field.appliedDirectivesOf(metadata.requiresDirective())) {
                addExternalFieldsFromDirectiveFieldSet(subgraph, type, requiresApplication, supergraph);
            }
            const fieldBaseType = (0, definitions_1.baseType)(field.type);
            for (const providesApplication of field.appliedDirectivesOf(metadata.providesDirective())) {
                (0, utils_1.assert)((0, definitions_1.isObjectType)(fieldBaseType) || (0, definitions_1.isInterfaceType)(fieldBaseType), () => `Found @provides on field ${field.coordinate} whose type ${field.type} (${fieldBaseType.kind}) is not an object or interface `);
                addExternalFieldsFromDirectiveFieldSet(subgraph, fieldBaseType, providesApplication, supergraph);
            }
        }
        addExternalFieldsFromInterface(metadata, type);
    }
}
function addExternalFieldsFromDirectiveFieldSet(subgraph, parentType, directive, supergraph, forceNonExternal = false) {
    const external = subgraph.metadata().externalDirective();
    const fieldAccessor = function (type, fieldName) {
        const field = type.field(fieldName);
        if (field) {
            if (forceNonExternal && field.hasAppliedDirective(external)) {
                field.appliedDirectivesOf(external).forEach(d => d.remove());
            }
            return field;
        }
        (0, utils_1.assert)(!(0, definitions_1.isUnionType)(type), () => `Shouldn't select field ${fieldName} from union type ${type}`);
        const supergraphType = supergraph.type(type.name);
        const supergraphField = supergraphType.field(fieldName);
        (0, utils_1.assert)(supergraphField, () => `No field named ${fieldName} found on type ${type.name} in the supergraph`);
        const created = addSubgraphObjectOrInterfaceField(supergraphField, subgraph);
        if (!forceNonExternal) {
            created.applyDirective(external);
        }
        return created;
    };
    try {
        (0, federation_1.parseFieldSetArgument)({ parentType, directive, fieldAccessor, validate: false });
    }
    catch (e) {
    }
}
function addExternalFieldsFromInterface(metadata, type) {
    for (const itf of type.interfaces()) {
        for (const field of itf.fields()) {
            const typeField = type.field(field.name);
            if (!typeField) {
                copyFieldAsExternal(metadata, field, type);
            }
            else if (typeField.hasAppliedDirective(metadata.externalDirective())) {
                maybeUpdateFieldForInterface(typeField, field);
            }
        }
    }
}
function copyFieldAsExternal(metadata, field, type) {
    const newField = type.addField(field.name, field.type);
    for (const arg of field.arguments()) {
        newField.addArgument(arg.name, arg.type, arg.defaultValue);
    }
    newField.applyDirective(metadata.externalDirective());
}
function maybeUpdateFieldForInterface(toModify, itfField) {
    if (!(0, types_1.isSubtype)(itfField.type, toModify.type)) {
        (0, utils_1.assert)((0, types_1.isSubtype)(toModify.type, itfField.type), () => `For ${toModify.coordinate}, expected ${itfField.type} and ${toModify.type} to be in a subtyping relationship`);
        toModify.type = itfField.type;
    }
}
//# sourceMappingURL=extractSubgraphsFromSupergraph.js.map