import { ArgumentNode, DocumentNode, FieldNode, FragmentDefinitionNode, FragmentSpreadNode, InlineFragmentNode, SelectionNode, SelectionSetNode } from "graphql";
import { Directive, DirectiveTargetElement, FieldDefinition, InterfaceType, ObjectType, Schema, SchemaRootKind, VariableCollector, VariableDefinitions, CompositeType, DeferDirectiveArgs, Variable, Type, Variables } from "./definitions";
import { SetMultiMap } from "./utils";
declare abstract class AbstractOperationElement<T extends AbstractOperationElement<T>> extends DirectiveTargetElement<T> {
    private attachements?;
    constructor(schema: Schema, directives?: readonly Directive<any>[]);
    collectVariables(collector: VariableCollector): void;
    abstract key(): string;
    abstract asPathElement(): string | undefined;
    abstract rebaseOn(parentType: CompositeType): T;
    abstract withUpdatedDirectives(newDirectives: readonly Directive<any>[]): T;
    protected abstract collectVariablesInElement(collector: VariableCollector): void;
    addAttachement(key: string, value: string): void;
    getAttachement(key: string): string | undefined;
    protected copyAttachementsTo(elt: AbstractOperationElement<any>): void;
}
export declare class Field<TArgs extends {
    [key: string]: any;
} = {
    [key: string]: any;
}> extends AbstractOperationElement<Field<TArgs>> {
    readonly definition: FieldDefinition<CompositeType>;
    private readonly args?;
    readonly alias?: string | undefined;
    readonly kind: "Field";
    constructor(definition: FieldDefinition<CompositeType>, args?: TArgs | undefined, directives?: readonly Directive<any>[], alias?: string | undefined);
    protected collectVariablesInElement(collector: VariableCollector): void;
    get name(): string;
    argumentValue(name: string): any;
    responseName(): string;
    key(): string;
    asPathElement(): string;
    get parentType(): CompositeType;
    isLeafField(): boolean;
    withUpdatedDefinition(newDefinition: FieldDefinition<any>): Field<TArgs>;
    withUpdatedAlias(newAlias: string | undefined): Field<TArgs>;
    withUpdatedDirectives(newDirectives: readonly Directive<any>[]): Field<TArgs>;
    argumentsToNodes(): ArgumentNode[] | undefined;
    appliesTo(type: ObjectType | InterfaceType): boolean;
    selects(definition: FieldDefinition<any>, assumeValid?: boolean, variableDefinitions?: VariableDefinitions): boolean;
    validate(variableDefinitions: VariableDefinitions): void;
    rebaseOn(parentType: CompositeType): Field<TArgs>;
    private canRebaseOn;
    typeIfAddedTo(parentType: CompositeType): Type | undefined;
    hasDefer(): boolean;
    deferDirectiveArgs(): undefined;
    withoutDefer(): Field<TArgs>;
    equals(that: OperationElement): boolean;
    toString(): string;
}
export declare class FragmentElement extends AbstractOperationElement<FragmentElement> {
    private readonly sourceType;
    readonly kind: "FragmentElement";
    readonly typeCondition?: CompositeType;
    private computedKey;
    constructor(sourceType: CompositeType, typeCondition?: string | CompositeType, directives?: readonly Directive<any>[]);
    protected collectVariablesInElement(_: VariableCollector): void;
    get parentType(): CompositeType;
    key(): string;
    castedType(): CompositeType;
    asPathElement(): string | undefined;
    withUpdatedSourceType(newSourceType: CompositeType): FragmentElement;
    withUpdatedCondition(newCondition: CompositeType | undefined): FragmentElement;
    withUpdatedTypes(newSourceType: CompositeType, newCondition: CompositeType | undefined): FragmentElement;
    withUpdatedDirectives(newDirectives: Directive<OperationElement>[]): FragmentElement;
    rebaseOn(parentType: CompositeType): FragmentElement;
    private canRebaseOn;
    castedTypeIfAddedTo(parentType: CompositeType): CompositeType | undefined;
    hasDefer(): boolean;
    hasStream(): boolean;
    deferDirectiveArgs(): DeferDirectiveArgs | undefined;
    withoutDefer(): FragmentElement | undefined;
    withNormalizedDefer(normalizer: DeferNormalizer): FragmentElement | undefined;
    equals(that: OperationElement): boolean;
    toString(): string;
}
export type OperationElement = Field<any> | FragmentElement;
export type OperationPath = OperationElement[];
export declare function operationPathToStringPath(path: OperationPath): string[];
export declare function sameOperationPaths(p1: OperationPath, p2: OperationPath): boolean;
export declare function conditionalDirectivesInOperationPath(path: OperationPath): Directive<any, any>[];
export declare function concatOperationPaths(head: OperationPath, tail: OperationPath): OperationPath;
export type RootOperationPath = {
    rootKind: SchemaRootKind;
    path: OperationPath;
};
export declare class Operation {
    readonly schema: Schema;
    readonly rootKind: SchemaRootKind;
    readonly selectionSet: SelectionSet;
    readonly variableDefinitions: VariableDefinitions;
    readonly name?: string | undefined;
    constructor(schema: Schema, rootKind: SchemaRootKind, selectionSet: SelectionSet, variableDefinitions: VariableDefinitions, name?: string | undefined);
    optimize(fragments?: NamedFragments, minUsagesToOptimize?: number): Operation;
    expandAllFragments(): Operation;
    trimUnsatisfiableBranches(): Operation;
    withoutDefer(labelsToRemove?: Set<string>): Operation;
    withNormalizedDefer(): {
        operation: Operation;
        hasDefers: boolean;
        assignedDeferLabels: Set<string>;
        deferConditions: SetMultiMap<string, string>;
    };
    collectDefaultedVariableValues(): Record<string, any>;
    toString(expandFragments?: boolean, prettyPrint?: boolean): string;
}
export declare class NamedFragmentDefinition extends DirectiveTargetElement<NamedFragmentDefinition> {
    readonly name: string;
    readonly typeCondition: CompositeType;
    private _selectionSet;
    constructor(schema: Schema, name: string, typeCondition: CompositeType, directives?: Directive<NamedFragmentDefinition>[]);
    setSelectionSet(selectionSet: SelectionSet): NamedFragmentDefinition;
    get selectionSet(): SelectionSet;
    withUpdatedSelectionSet(newSelectionSet: SelectionSet): NamedFragmentDefinition;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    toFragmentDefinitionNode(): FragmentDefinitionNode;
    canApplyAtType(type: CompositeType): boolean;
    private validForSchema;
    toString(indent?: string): string;
}
export declare class NamedFragments {
    private readonly fragments;
    isEmpty(): boolean;
    names(): readonly string[];
    add(fragment: NamedFragmentDefinition): void;
    addIfNotExist(fragment: NamedFragmentDefinition): void;
    maybeApplyingAtType(type: CompositeType): NamedFragmentDefinition[];
    without(names: string[]): NamedFragments | undefined;
    get(name: string): NamedFragmentDefinition | undefined;
    has(name: string): boolean;
    definitions(): readonly NamedFragmentDefinition[];
    map(mapper: (def: NamedFragmentDefinition) => NamedFragmentDefinition): NamedFragments;
    validate(variableDefinitions: VariableDefinitions): void;
    toFragmentDefinitionNodes(): FragmentDefinitionNode[];
    toString(indent?: string): string;
}
declare class DeferNormalizer {
    private index;
    readonly assignedLabels: Set<string>;
    readonly deferConditions: SetMultiMap<string, string>;
    private readonly usedLabels;
    init(selectionSet: SelectionSet): {
        hasDefers: boolean;
        hasNonLabelledOrConditionalDefers: boolean;
    };
    private nextLabel;
    newLabel(): string;
    registerCondition(label: string, condition: Variable): void;
}
export declare class SelectionSet {
    readonly parentType: CompositeType;
    readonly fragments?: NamedFragments | undefined;
    private readonly _keyedSelections;
    private readonly _selections;
    constructor(parentType: CompositeType, keyedSelections?: Map<string, Selection>, fragments?: NamedFragments | undefined);
    selectionsInReverseOrder(): readonly Selection[];
    selections(): readonly Selection[];
    hasTopLevelTypenameField(): boolean;
    fieldsInSet(): {
        path: string[];
        field: FieldSelection;
    }[];
    usedVariables(): Variables;
    collectVariables(collector: VariableCollector): void;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    optimize(fragments?: NamedFragments): SelectionSet;
    expandAllFragments(): SelectionSet;
    expandFragments(names: string[], updatedFragments: NamedFragments | undefined): SelectionSet;
    trimUnsatisfiableBranches(parentType: CompositeType): SelectionSet;
    lazyMap(mapper: (selection: Selection) => Selection | readonly Selection[] | SelectionSet | undefined, options?: {
        fragments?: NamedFragments | null;
        parentType?: CompositeType;
    }): SelectionSet;
    private withUpdatedFragments;
    withoutDefer(labelsToRemove?: Set<string>): SelectionSet;
    withNormalizedDefer(normalizer: DeferNormalizer): SelectionSet;
    hasDefer(): boolean;
    filter(predicate: (selection: Selection) => boolean): SelectionSet;
    withoutEmptyBranches(): SelectionSet | undefined;
    rebaseOn(parentType: CompositeType): SelectionSet;
    equals(that: SelectionSet): boolean;
    private triviallyNestedSelectionsForKey;
    private mergeSameKeySelections;
    contains(that: SelectionSet): boolean;
    diffIfContains(that: SelectionSet): {
        contains: boolean;
        diff?: SelectionSet;
    };
    minus(that: SelectionSet): SelectionSet;
    canRebaseOn(parentTypeToTest: CompositeType): boolean;
    validate(variableDefinitions: VariableDefinitions): void;
    isEmpty(): boolean;
    toSelectionSetNode(): SelectionSetNode;
    private selectionsInPrintOrder;
    toOperationPaths(): OperationPath[];
    private toOperationPathsInternal;
    forEachElement(callback: (elt: OperationElement) => void): void;
    some(predicate: (elt: OperationElement) => boolean): boolean;
    toOperationString(rootKind: SchemaRootKind, variableDefinitions: VariableDefinitions, operationName?: string, expandFragments?: boolean, prettyPrint?: boolean): string;
    toString(expandFragments?: boolean, includeExternalBrackets?: boolean, indent?: string): string;
}
export declare class SelectionSetUpdates {
    private readonly keyedUpdates;
    isEmpty(): boolean;
    add(selections: Selection | SelectionSet | readonly Selection[]): SelectionSetUpdates;
    addAtPath(path: OperationPath, selections?: Selection | SelectionSet | readonly Selection[]): SelectionSetUpdates;
    clone(): SelectionSetUpdates;
    clear(): void;
    toSelectionSet(parentType: CompositeType, fragments?: NamedFragments): SelectionSet;
}
export declare class MutableSelectionSet<TMemoizedValue extends {
    [key: string]: any;
} = {}> {
    readonly parentType: CompositeType;
    private readonly _updates;
    private readonly memoizer;
    private computed;
    private _memoized;
    private constructor();
    static empty(parentType: CompositeType): MutableSelectionSet;
    static emptyWithMemoized<TMemoizedValue extends {
        [key: string]: any;
    }>(parentType: CompositeType, memoizer: (s: SelectionSet) => TMemoizedValue): MutableSelectionSet<TMemoizedValue>;
    static of(selectionSet: SelectionSet): MutableSelectionSet;
    static ofWithMemoized<TMemoizedValue extends {
        [key: string]: any;
    }>(selectionSet: SelectionSet, memoizer: (s: SelectionSet) => TMemoizedValue): MutableSelectionSet<TMemoizedValue>;
    isEmpty(): boolean;
    get(): SelectionSet;
    updates(): SelectionSetUpdates;
    clone(): MutableSelectionSet<TMemoizedValue>;
    rebaseOn(parentType: CompositeType): MutableSelectionSet<TMemoizedValue>;
    memoized(): TMemoizedValue;
    toString(): string;
}
export declare function allFieldDefinitionsInSelectionSet(selection: SelectionSet): FieldDefinition<CompositeType>[];
export declare function selectionSetOf(parentType: CompositeType, selection: Selection, fragments?: NamedFragments): SelectionSet;
export declare function selectionSetOfElement(element: OperationElement, subSelection?: SelectionSet, fragments?: NamedFragments): SelectionSet;
export declare function selectionOfElement(element: OperationElement, subSelection?: SelectionSet): Selection;
export type Selection = FieldSelection | FragmentSelection;
declare abstract class AbstractSelection<TElement extends OperationElement, TIsLeaf extends undefined | never, TOwnType extends AbstractSelection<TElement, TIsLeaf, TOwnType>> {
    readonly element: TElement;
    constructor(element: TElement);
    abstract get selectionSet(): SelectionSet | TIsLeaf;
    protected abstract us(): TOwnType;
    abstract key(): string;
    abstract optimize(fragments: NamedFragments): Selection;
    abstract toSelectionNode(): SelectionNode;
    abstract validate(variableDefinitions: VariableDefinitions): void;
    abstract rebaseOn(parentType: CompositeType): TOwnType;
    get parentType(): CompositeType;
    collectVariables(collector: VariableCollector): void;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    namedFragments(): NamedFragments | undefined;
    abstract withUpdatedComponents(element: TElement, selectionSet: SelectionSet | TIsLeaf): TOwnType;
    withUpdatedSelectionSet(selectionSet: SelectionSet | TIsLeaf): TOwnType;
    withUpdatedElement(element: TElement): TOwnType;
    mapToSelectionSet(mapper: (s: SelectionSet) => SelectionSet): TOwnType;
    abstract withoutDefer(labelsToRemove?: Set<string>): TOwnType | SelectionSet;
    abstract withNormalizedDefer(normalizer: DeferNormalizer): TOwnType | SelectionSet;
    abstract hasDefer(): boolean;
    abstract expandAllFragments(): TOwnType | readonly Selection[];
    abstract expandFragments(names: string[], updatedFragments: NamedFragments | undefined): TOwnType | readonly Selection[];
    abstract trimUnsatisfiableBranches(parentType: CompositeType): TOwnType | SelectionSet | undefined;
    minus(that: Selection): TOwnType | undefined;
    protected tryOptimizeSubselectionOnce(_: {
        parentType: CompositeType;
        subSelection: SelectionSet;
        candidates: NamedFragmentDefinition[];
        fragments: NamedFragments;
    }): {
        spread?: FragmentSpreadSelection;
        optimizedSelection?: SelectionSet;
        hasDiff?: boolean;
    };
    protected tryOptimizeSubselectionWithFragments({ parentType, subSelection, fragments, fragmentFilter, }: {
        parentType: CompositeType;
        subSelection: SelectionSet;
        fragments: NamedFragments;
        fragmentFilter?: (f: NamedFragmentDefinition) => boolean;
    }): SelectionSet | FragmentSpreadSelection;
}
export declare class FieldSelection extends AbstractSelection<Field<any>, undefined, FieldSelection> {
    private readonly _selectionSet?;
    readonly kind: "FieldSelection";
    constructor(field: Field<any>, _selectionSet?: SelectionSet | undefined);
    get selectionSet(): SelectionSet | undefined;
    protected us(): FieldSelection;
    withUpdatedComponents(field: Field<any>, selectionSet: SelectionSet | undefined): FieldSelection;
    key(): string;
    optimize(fragments: NamedFragments): Selection;
    protected tryOptimizeSubselectionOnce({ parentType, subSelection, candidates, fragments, }: {
        parentType: CompositeType;
        subSelection: SelectionSet;
        candidates: NamedFragmentDefinition[];
        fragments: NamedFragments;
    }): {
        spread?: FragmentSpreadSelection;
        optimizedSelection?: SelectionSet;
        hasDiff?: boolean;
    };
    filter(predicate: (selection: Selection) => boolean): FieldSelection | undefined;
    validate(variableDefinitions: VariableDefinitions): void;
    rebaseOn(parentType: CompositeType): FieldSelection;
    canAddTo(parentType: CompositeType): boolean;
    toSelectionNode(): FieldNode;
    withoutDefer(labelsToRemove?: Set<string>): FieldSelection;
    withNormalizedDefer(normalizer: DeferNormalizer): FieldSelection;
    hasDefer(): boolean;
    expandAllFragments(): FieldSelection;
    trimUnsatisfiableBranches(_: CompositeType): FieldSelection;
    expandFragments(names: string[], updatedFragments: NamedFragments | undefined): FieldSelection;
    equals(that: Selection): boolean;
    contains(that: Selection): boolean;
    isUnecessaryInlineFragment(_: CompositeType): this is InlineFragmentSelection;
    toString(expandFragments?: boolean, indent?: string): string;
}
export declare abstract class FragmentSelection extends AbstractSelection<FragmentElement, never, FragmentSelection> {
    readonly kind: "FragmentSelection";
    abstract canAddTo(parentType: CompositeType): boolean;
    protected us(): FragmentSelection;
    protected validateDeferAndStream(): void;
    filter(predicate: (selection: Selection) => boolean): FragmentSelection | undefined;
    hasDefer(): boolean;
    abstract equals(that: Selection): boolean;
    abstract contains(that: Selection): boolean;
    isUnecessaryInlineFragment(parentType: CompositeType): boolean;
}
declare class InlineFragmentSelection extends FragmentSelection {
    private readonly _selectionSet;
    constructor(fragment: FragmentElement, _selectionSet: SelectionSet);
    get selectionSet(): SelectionSet;
    key(): string;
    withUpdatedComponents(fragment: FragmentElement, selectionSet: SelectionSet): InlineFragmentSelection;
    validate(variableDefinitions: VariableDefinitions): void;
    rebaseOn(parentType: CompositeType): FragmentSelection;
    canAddTo(parentType: CompositeType): boolean;
    toSelectionNode(): InlineFragmentNode;
    optimize(fragments: NamedFragments): FragmentSelection;
    protected tryOptimizeSubselectionOnce({ parentType, subSelection, candidates, fragments, }: {
        parentType: CompositeType;
        subSelection: SelectionSet;
        candidates: NamedFragmentDefinition[];
        fragments: NamedFragments;
    }): {
        spread?: FragmentSpreadSelection;
        optimizedSelection?: SelectionSet;
        hasDiff?: boolean;
    };
    withoutDefer(labelsToRemove?: Set<string>): InlineFragmentSelection | SelectionSet;
    withNormalizedDefer(normalizer: DeferNormalizer): InlineFragmentSelection | SelectionSet;
    trimUnsatisfiableBranches(currentType: CompositeType): FragmentSelection | SelectionSet | undefined;
    expandAllFragments(): FragmentSelection;
    expandFragments(names: string[], updatedFragments: NamedFragments | undefined): FragmentSelection;
    equals(that: Selection): boolean;
    contains(that: Selection): boolean;
    toString(expandFragments?: boolean, indent?: string): string;
}
declare class FragmentSpreadSelection extends FragmentSelection {
    private readonly fragments;
    readonly namedFragment: NamedFragmentDefinition;
    private readonly spreadDirectives;
    private computedKey;
    constructor(sourceType: CompositeType, fragments: NamedFragments, namedFragment: NamedFragmentDefinition, spreadDirectives: readonly Directive<any>[]);
    get selectionSet(): SelectionSet;
    key(): string;
    withUpdatedComponents(_fragment: FragmentElement, _selectionSet: SelectionSet): InlineFragmentSelection;
    trimUnsatisfiableBranches(_: CompositeType): FragmentSelection;
    namedFragments(): NamedFragments | undefined;
    validate(): void;
    toSelectionNode(): FragmentSpreadNode;
    optimize(_: NamedFragments): FragmentSelection;
    rebaseOn(_parentType: CompositeType): FragmentSelection;
    canAddTo(_: CompositeType): boolean;
    expandAllFragments(): FragmentSelection | readonly Selection[];
    expandFragments(names: string[], updatedFragments: NamedFragments | undefined): FragmentSelection | readonly Selection[];
    collectUsedFragmentNames(collector: Map<string, number>): void;
    withoutDefer(_labelsToRemove?: Set<string>): FragmentSpreadSelection;
    withNormalizedDefer(_normalizer: DeferNormalizer): FragmentSpreadSelection;
    minus(that: Selection): undefined;
    equals(that: Selection): boolean;
    contains(that: Selection): boolean;
    toString(expandFragments?: boolean, indent?: string): string;
}
export declare function operationFromDocument(schema: Schema, document: DocumentNode, options?: {
    operationName?: string;
    validate?: boolean;
}): Operation;
export declare function parseOperation(schema: Schema, operation: string, options?: {
    operationName?: string;
    validate?: boolean;
}): Operation;
export declare function parseSelectionSet({ parentType, source, variableDefinitions, fragments, fieldAccessor, validate, }: {
    parentType: CompositeType;
    source: string | SelectionSetNode;
    variableDefinitions?: VariableDefinitions;
    fragments?: NamedFragments;
    fieldAccessor?: (type: CompositeType, fieldName: string) => (FieldDefinition<any> | undefined);
    validate?: boolean;
}): SelectionSet;
export declare function operationToDocument(operation: Operation): DocumentNode;
export {};
//# sourceMappingURL=operations.d.ts.map