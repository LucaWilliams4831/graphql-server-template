"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationState = exports.ValidationContext = exports.extractValidationError = exports.computeSubgraphPaths = exports.validateGraphComposition = exports.ValidationError = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const query_graphs_1 = require("@apollo/query-graphs");
const hints_1 = require("./hints");
const graphql_1 = require("graphql");
const debug = (0, federation_internals_1.newDebugLogger)('validation');
class ValidationError extends Error {
    constructor(message, supergraphUnsatisfiablePath, subgraphsPaths, witness) {
        super(message);
        this.supergraphUnsatisfiablePath = supergraphUnsatisfiablePath;
        this.subgraphsPaths = subgraphsPaths;
        this.witness = witness;
        this.name = 'ValidationError';
    }
}
exports.ValidationError = ValidationError;
function satisfiabilityError(unsatisfiablePath, subgraphsPaths, subgraphsPathsUnadvanceables) {
    const witness = buildWitnessOperation(unsatisfiablePath);
    const operation = (0, graphql_1.print)((0, federation_internals_1.operationToDocument)(witness));
    const message = `The following supergraph API query:\n${operation}\n`
        + 'cannot be satisfied by the subgraphs because:\n'
        + displayReasons(subgraphsPathsUnadvanceables);
    const error = new ValidationError(message, unsatisfiablePath, subgraphsPaths, witness);
    return federation_internals_1.ERRORS.SATISFIABILITY_ERROR.err(error.message, {
        originalError: error,
    });
}
function subgraphNodes(state, extractNode) {
    return state.currentSubgraphs().map(({ name, schema }) => {
        const node = extractNode(schema);
        return node ? (0, federation_internals_1.addSubgraphToASTNode)(node, name) : undefined;
    }).filter(federation_internals_1.isDefined);
}
function shareableFieldNonIntersectingRuntimeTypesError(invalidState, field, runtimeTypesToSubgraphs) {
    const witness = buildWitnessOperation(invalidState.supergraphPath);
    const operation = (0, graphql_1.print)((0, federation_internals_1.operationToDocument)(witness));
    const typeStrings = [...runtimeTypesToSubgraphs].map(([ts, subgraphs]) => ` - in ${(0, federation_internals_1.printSubgraphNames)(subgraphs)}, ${ts}`);
    const message = `For the following supergraph API query:\n${operation}`
        + `\nShared field "${field.coordinate}" return type "${field.type}" has a non-intersecting set of possible runtime types across subgraphs. Runtime types in subgraphs are:`
        + `\n${typeStrings.join(';\n')}.`
        + `\nThis is not allowed as shared fields must resolve the same way in all subgraphs, and that imply at least some common runtime types between the subgraphs.`;
    const error = new ValidationError(message, invalidState.supergraphPath, invalidState.subgraphPaths.map((p) => p.path), witness);
    return federation_internals_1.ERRORS.SHAREABLE_HAS_MISMATCHED_RUNTIME_TYPES.err(error.message, {
        nodes: subgraphNodes(invalidState, (s) => { var _a, _b; return (_b = (_a = s.type(field.parent.name)) === null || _a === void 0 ? void 0 : _a.field(field.name)) === null || _b === void 0 ? void 0 : _b.sourceAST; }),
    });
}
function shareableFieldMismatchedRuntimeTypesHint(state, field, commonRuntimeTypes, runtimeTypesPerSubgraphs) {
    const witness = buildWitnessOperation(state.supergraphPath);
    const operation = (0, graphql_1.print)((0, federation_internals_1.operationToDocument)(witness));
    const allSubgraphs = state.currentSubgraphNames();
    const printTypes = (ts) => (0, federation_internals_1.printHumanReadableList)(ts.map((t) => '"' + t + '"'), {
        prefix: 'type',
        prefixPlural: 'types'
    });
    const subgraphsWithTypeNotInIntersectionString = allSubgraphs.map((s) => {
        const typesToNotImplement = runtimeTypesPerSubgraphs.get(s).filter((t) => !commonRuntimeTypes.includes(t));
        if (typesToNotImplement.length === 0) {
            return undefined;
        }
        return ` - subgraph "${s}" should never resolve "${field.coordinate}" to an object of ${printTypes(typesToNotImplement)}`;
    }).filter(federation_internals_1.isDefined);
    const message = `For the following supergraph API query:\n${operation}`
        + `\nShared field "${field.coordinate}" return type "${field.type}" has different sets of possible runtime types across subgraphs.`
        + `\nSince a shared field must be resolved the same way in all subgraphs, make sure that ${(0, federation_internals_1.printSubgraphNames)(allSubgraphs)} only resolve "${field.coordinate}" to objects of ${printTypes(commonRuntimeTypes)}. In particular:`
        + `\n${subgraphsWithTypeNotInIntersectionString.join(';\n')}.`
        + `\nOtherwise the @shareable contract will be broken.`;
    return new hints_1.CompositionHint(hints_1.HINTS.INCONSISTENT_RUNTIME_TYPES_FOR_SHAREABLE_RETURN, message, subgraphNodes(state, (s) => { var _a, _b; return (_b = (_a = s.type(field.parent.name)) === null || _a === void 0 ? void 0 : _a.field(field.name)) === null || _b === void 0 ? void 0 : _b.sourceAST; }));
}
function displayReasons(reasons) {
    const bySubgraph = new federation_internals_1.MultiMap();
    for (const reason of reasons) {
        for (const unadvanceable of reason.reasons) {
            bySubgraph.add(unadvanceable.sourceSubgraph, unadvanceable);
        }
    }
    return [...bySubgraph.entries()].map(([subgraph, reasons]) => {
        let msg = `- from subgraph "${subgraph}":`;
        if (reasons.length === 1) {
            msg += ' ' + reasons[0].details + '.';
        }
        else {
            const allDetails = new Set(reasons.map((r) => r.details));
            for (const details of allDetails) {
                msg += '\n  - ' + details + '.';
            }
        }
        return msg;
    }).join('\n');
}
function buildWitnessOperation(witness) {
    (0, federation_internals_1.assert)(witness.size > 0, "unsatisfiablePath should contain at least one edge/transition");
    const root = witness.root;
    const schema = witness.graph.sources.get(root.source);
    return new federation_internals_1.Operation(schema, root.rootKind, buildWitnessNextStep([...witness].map(e => e[0]), 0), new federation_internals_1.VariableDefinitions());
}
function buildWitnessNextStep(edges, index) {
    if (index >= edges.length) {
        const lastType = edges[edges.length - 1].tail.type;
        (0, federation_internals_1.assert)((0, federation_internals_1.isOutputType)(lastType), 'Should not have input types as vertex types');
        return (0, federation_internals_1.isLeafType)(lastType) ? undefined : new federation_internals_1.SelectionSet(lastType);
    }
    const edge = edges[index];
    let selection;
    const subSelection = buildWitnessNextStep(edges, index + 1);
    switch (edge.transition.kind) {
        case 'DownCast':
            const type = edge.transition.castedType;
            selection = (0, federation_internals_1.selectionOfElement)(new federation_internals_1.FragmentElement(edge.transition.sourceType, type.name), subSelection);
            break;
        case 'FieldCollection':
            const field = edge.transition.definition;
            selection = new federation_internals_1.FieldSelection(buildWitnessField(field), subSelection);
            break;
        case 'SubgraphEnteringTransition':
        case 'KeyResolution':
        case 'RootTypeResolution':
        case 'InterfaceObjectFakeDownCast':
            (0, federation_internals_1.assert)(false, `Invalid edge ${edge} found in supergraph path`);
    }
    return (0, federation_internals_1.selectionSetOf)(edge.head.type, selection);
}
function buildWitnessField(definition) {
    if (definition.arguments().length === 0) {
        return new federation_internals_1.Field(definition);
    }
    const args = Object.create(null);
    for (const argDef of definition.arguments()) {
        args[argDef.name] = generateWitnessValue(argDef.type);
    }
    return new federation_internals_1.Field(definition, args);
}
function generateWitnessValue(type) {
    switch (type.kind) {
        case 'ScalarType':
            switch (type.name) {
                case 'Int':
                    return 0;
                case 'Float':
                    return 3.14;
                case 'Boolean':
                    return true;
                case 'String':
                    return 'A string value';
                case 'ID':
                    return '<any id>';
                default:
                    return '<some value>';
            }
        case 'EnumType':
            return type.values[0].name;
        case 'InputObjectType':
            const obj = Object.create(null);
            for (const field of type.fields()) {
                if (field.defaultValue || (0, federation_internals_1.isNullableType)(field.type)) {
                    continue;
                }
                obj[field.name] = generateWitnessValue(field.type);
            }
            return obj;
        case 'ListType':
            return [];
        case 'NonNullType':
            return generateWitnessValue(type.ofType);
        default:
            (0, federation_internals_1.assert)(false, `Unhandled input type ${type}`);
    }
}
function validateGraphComposition(supergraphSchema, supergraphAPI, subgraphs) {
    const { errors, hints } = new ValidationTraversal(supergraphSchema, supergraphAPI, subgraphs).validate();
    return errors.length > 0 ? { errors, hints } : { hints };
}
exports.validateGraphComposition = validateGraphComposition;
function computeSubgraphPaths(supergraphSchema, supergraphPath, subgraphs) {
    try {
        (0, federation_internals_1.assert)(!supergraphPath.hasAnyEdgeConditions(), () => `A supergraph path should not have edge condition paths (as supergraph edges should not have conditions): ${supergraphPath}`);
        const conditionResolver = new ConditionValidationResolver(supergraphSchema, subgraphs);
        const initialState = ValidationState.initial({ supergraphAPI: supergraphPath.graph, kind: supergraphPath.root.rootKind, subgraphs, conditionResolver });
        const context = new ValidationContext(supergraphSchema);
        let state = initialState;
        let isIncomplete = false;
        for (const [edge] of supergraphPath) {
            const { state: updated, error } = state.validateTransition(context, edge);
            if (error) {
                throw error;
            }
            if (!updated) {
                isIncomplete = true;
                break;
            }
            state = updated;
        }
        return { traversal: state, isComplete: !isIncomplete };
    }
    catch (error) {
        if (error instanceof graphql_1.GraphQLError) {
            return { error };
        }
        throw error;
    }
}
exports.computeSubgraphPaths = computeSubgraphPaths;
function initialSubgraphPaths(kind, subgraphs) {
    const root = subgraphs.root(kind);
    (0, federation_internals_1.assert)(root, () => `The supergraph shouldn't have a ${kind} root if no subgraphs have one`);
    (0, federation_internals_1.assert)(root.type.name == (0, query_graphs_1.federatedGraphRootTypeName)(kind), () => `Unexpected type ${root.type} for subgraphs root type (expected ${(0, query_graphs_1.federatedGraphRootTypeName)(kind)}`);
    const initialState = query_graphs_1.GraphPath.fromGraphRoot(subgraphs, kind);
    return subgraphs.outEdges(root).map(e => initialState.add(query_graphs_1.subgraphEnteringTransition, e, query_graphs_1.noConditionsResolution));
}
function possibleRuntimeTypeNamesSorted(path) {
    const types = path.tailPossibleRuntimeTypes().map((o) => o.name);
    types.sort((a, b) => a.localeCompare(b));
    return types;
}
function extractValidationError(error) {
    if (!(error instanceof graphql_1.GraphQLError) || !(error.originalError instanceof ValidationError)) {
        return undefined;
    }
    return error.originalError;
}
exports.extractValidationError = extractValidationError;
class ValidationContext {
    constructor(supergraphSchema) {
        this.supergraphSchema = supergraphSchema;
        const [_, joinSpec] = (0, federation_internals_1.validateSupergraph)(supergraphSchema);
        this.joinTypeDirective = joinSpec.typeDirective(supergraphSchema);
        this.joinFieldDirective = joinSpec.fieldDirective(supergraphSchema);
    }
    isShareable(field) {
        const typeInSupergraph = this.supergraphSchema.type(field.parent.name);
        (0, federation_internals_1.assert)(typeInSupergraph && (0, federation_internals_1.isCompositeType)(typeInSupergraph), () => `${field.parent.name} should exists in the supergraph and be a composite`);
        if (!(0, federation_internals_1.isObjectType)(typeInSupergraph)) {
            return false;
        }
        const fieldInSupergraph = typeInSupergraph.field(field.name);
        (0, federation_internals_1.assert)(fieldInSupergraph, () => `${field.coordinate} should exists in the supergraph`);
        const joinFieldApplications = fieldInSupergraph.appliedDirectivesOf(this.joinFieldDirective);
        return joinFieldApplications.length === 0
            ? typeInSupergraph.appliedDirectivesOf(this.joinTypeDirective).length > 1
            : (joinFieldApplications.filter((application) => {
                const args = application.arguments();
                return !args.external && !args.usedOverridden;
            }).length > 1);
    }
}
exports.ValidationContext = ValidationContext;
class ValidationState {
    constructor(supergraphPath, subgraphPaths) {
        this.supergraphPath = supergraphPath;
        this.subgraphPaths = subgraphPaths;
    }
    static initial({ supergraphAPI, kind, subgraphs, conditionResolver, }) {
        return new ValidationState(query_graphs_1.GraphPath.fromGraphRoot(supergraphAPI, kind), initialSubgraphPaths(kind, subgraphs).map((p) => query_graphs_1.TransitionPathWithLazyIndirectPaths.initial(p, conditionResolver.resolver)));
    }
    validateTransition(context, supergraphEdge) {
        (0, federation_internals_1.assert)(!supergraphEdge.conditions, () => `Supergraph edges should not have conditions (${supergraphEdge})`);
        const transition = supergraphEdge.transition;
        const targetType = supergraphEdge.tail.type;
        const newSubgraphPaths = [];
        const deadEnds = [];
        for (const path of this.subgraphPaths) {
            const options = (0, query_graphs_1.advancePathWithTransition)(path, transition, targetType);
            if ((0, query_graphs_1.isUnadvanceable)(options)) {
                deadEnds.push(options);
                continue;
            }
            if (options.length === 0) {
                return { state: undefined };
            }
            newSubgraphPaths.push(...options);
        }
        const newPath = this.supergraphPath.add(transition, supergraphEdge, query_graphs_1.noConditionsResolution);
        if (newSubgraphPaths.length === 0) {
            return { error: satisfiabilityError(newPath, this.subgraphPaths.map((p) => p.path), deadEnds) };
        }
        const updatedState = new ValidationState(newPath, newSubgraphPaths);
        let hint = undefined;
        if (newSubgraphPaths.length > 1
            && transition.kind === 'FieldCollection'
            && (0, federation_internals_1.isAbstractType)(newPath.tail.type)
            && context.isShareable(transition.definition)) {
            const filteredPaths = newSubgraphPaths.map((p) => p.path).filter((p) => (0, federation_internals_1.isAbstractType)(p.tail.type));
            if (filteredPaths.length > 1) {
                const allRuntimeTypes = possibleRuntimeTypeNamesSorted(newPath);
                let intersection = allRuntimeTypes;
                const runtimeTypesToSubgraphs = new federation_internals_1.MultiMap();
                const runtimeTypesPerSubgraphs = new federation_internals_1.MultiMap();
                let hasAllEmpty = true;
                for (const path of newSubgraphPaths) {
                    const subgraph = path.path.tail.source;
                    const typeNames = possibleRuntimeTypeNamesSorted(path.path);
                    runtimeTypesPerSubgraphs.set(subgraph, typeNames);
                    let typeNamesStr = 'no runtime type is defined';
                    if (typeNames.length > 0) {
                        typeNamesStr = (typeNames.length > 1 ? 'types ' : 'type ') + (0, federation_internals_1.joinStrings)(typeNames.map((n) => `"${n}"`));
                        hasAllEmpty = false;
                    }
                    runtimeTypesToSubgraphs.add(typeNamesStr, subgraph);
                    intersection = intersection.filter((t) => typeNames.includes(t));
                }
                if (!hasAllEmpty) {
                    if (intersection.length === 0) {
                        return { error: shareableFieldNonIntersectingRuntimeTypesError(updatedState, transition.definition, runtimeTypesToSubgraphs) };
                    }
                    if (runtimeTypesToSubgraphs.size > 1) {
                        hint = shareableFieldMismatchedRuntimeTypesHint(updatedState, transition.definition, intersection, runtimeTypesPerSubgraphs);
                    }
                }
            }
        }
        return { state: updatedState, hint };
    }
    currentSubgraphNames() {
        const subgraphs = [];
        for (const path of this.subgraphPaths) {
            const source = path.path.tail.source;
            if (!subgraphs.includes(source)) {
                subgraphs.push(source);
            }
        }
        return subgraphs;
    }
    currentSubgraphs() {
        if (this.subgraphPaths.length === 0) {
            return [];
        }
        const sources = this.subgraphPaths[0].path.graph.sources;
        return this.currentSubgraphNames().map((name) => ({ name, schema: sources.get(name) }));
    }
    toString() {
        return `${this.supergraphPath} <=> [${this.subgraphPaths.map(s => s.toString()).join(', ')}]`;
    }
}
exports.ValidationState = ValidationState;
function isSupersetOrEqual(maybeSuperset, other) {
    return other.every(v => maybeSuperset.includes(v));
}
class ValidationTraversal {
    constructor(supergraphSchema, supergraphAPI, subgraphs) {
        this.stack = [];
        this.validationErrors = [];
        this.validationHints = [];
        this.conditionResolver = new ConditionValidationResolver(supergraphSchema, subgraphs);
        supergraphAPI.rootKinds().forEach((kind) => this.stack.push(ValidationState.initial({
            supergraphAPI,
            kind,
            subgraphs,
            conditionResolver: this.conditionResolver
        })));
        this.previousVisits = new query_graphs_1.QueryGraphState(supergraphAPI);
        this.context = new ValidationContext(supergraphSchema);
    }
    validate() {
        while (this.stack.length > 0) {
            this.handleState(this.stack.pop());
        }
        return { errors: this.validationErrors, hints: this.validationHints };
    }
    handleState(state) {
        debug.group(() => `Validation: ${this.stack.length + 1} open states. Validating ${state}`);
        const vertex = state.supergraphPath.tail;
        const currentSources = state.currentSubgraphNames();
        const previousSeenSources = this.previousVisits.getVertexState(vertex);
        if (previousSeenSources) {
            for (const previousSources of previousSeenSources) {
                if (isSupersetOrEqual(currentSources, previousSources)) {
                    debug.groupEnd(`Has already validated this vertex.`);
                    return;
                }
            }
            previousSeenSources.push(currentSources);
        }
        else {
            this.previousVisits.setVertexState(vertex, [currentSources]);
        }
        for (const edge of state.supergraphPath.nextEdges()) {
            if (edge.isEdgeForField(federation_internals_1.typenameFieldName)) {
                continue;
            }
            debug.group(() => `Validating supergraph edge ${edge}`);
            const { state: newState, error, hint } = state.validateTransition(this.context, edge);
            if (error) {
                debug.groupEnd(`Validation error!`);
                this.validationErrors.push(error);
                continue;
            }
            if (hint) {
                this.validationHints.push(hint);
            }
            if (newState && !newState.supergraphPath.isTerminal()) {
                this.stack.push(newState);
                debug.groupEnd(() => `Reached new state ${newState}`);
            }
            else {
                debug.groupEnd(`Reached terminal vertex/cycle`);
            }
        }
        debug.groupEnd();
    }
}
class ConditionValidationState {
    constructor(selection, subgraphOptions) {
        this.selection = selection;
        this.subgraphOptions = subgraphOptions;
    }
    toString() {
        return `${this.selection} <=> ${(0, query_graphs_1.advanceOptionsToString)(this.subgraphOptions)}`;
    }
}
class ConditionValidationResolver {
    constructor(supergraphSchema, federatedQueryGraph) {
        this.supergraphSchema = supergraphSchema;
        this.federatedQueryGraph = federatedQueryGraph;
        this.resolver = (0, query_graphs_1.cachingConditionResolver)(federatedQueryGraph, (edge, context, excludedEdges, excludedConditions) => this.validateConditions(edge, context, excludedEdges, excludedConditions));
    }
    validateConditions(edge, context, excludedEdges, excludedConditions) {
        const conditions = edge.conditions;
        excludedConditions = (0, query_graphs_1.addConditionExclusion)(excludedConditions, conditions);
        const initialPath = query_graphs_1.GraphPath.create(this.federatedQueryGraph, edge.head);
        const initialOptions = [new query_graphs_1.SimultaneousPathsWithLazyIndirectPaths([initialPath], context, this.resolver, excludedEdges, excludedConditions)];
        const stack = [];
        for (const selection of conditions.selections()) {
            stack.push(new ConditionValidationState(selection, initialOptions));
        }
        while (stack.length > 0) {
            const state = stack.pop();
            const newStates = this.advanceState(state);
            if (newStates === null) {
                return query_graphs_1.unsatisfiedConditionsResolution;
            }
            newStates.forEach(s => stack.push(s));
        }
        return { satisfied: true, cost: 1 };
    }
    advanceState(state) {
        let newOptions = [];
        for (const paths of state.subgraphOptions) {
            const pathsOptions = (0, query_graphs_1.advanceSimultaneousPathsWithOperation)(this.supergraphSchema, paths, state.selection.element);
            if (!pathsOptions) {
                continue;
            }
            newOptions = newOptions.concat(pathsOptions);
        }
        if (newOptions.length === 0) {
            return null;
        }
        return state.selection.selectionSet ? state.selection.selectionSet.selections().map(s => new ConditionValidationState(s, newOptions)) : [];
    }
}
//# sourceMappingURL=validate.js.map