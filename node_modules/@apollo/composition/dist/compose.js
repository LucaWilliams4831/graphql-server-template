"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeServices = exports.compose = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const query_graphs_1 = require("@apollo/query-graphs");
const merging_1 = require("./merging");
const validate_1 = require("./validate");
function validateCompositionOptions(options) {
    var _a;
    (0, federation_internals_1.assert)(!((_a = options === null || options === void 0 ? void 0 : options.allowedFieldTypeMergingSubtypingRules) === null || _a === void 0 ? void 0 : _a.includes("list_upgrade")), "The `list_upgrade` field subtyping rule is currently not supported");
}
function compose(subgraphs, options = {}) {
    var _a;
    validateCompositionOptions(options);
    const upgradeResult = (0, federation_internals_1.upgradeSubgraphsIfNecessary)(subgraphs);
    if (upgradeResult.errors) {
        return { errors: upgradeResult.errors };
    }
    const toMerge = upgradeResult.subgraphs;
    const validationErrors = toMerge.validate();
    if (validationErrors) {
        return { errors: validationErrors };
    }
    const mergeResult = (0, merging_1.mergeSubgraphs)(toMerge);
    if (mergeResult.errors) {
        return { errors: mergeResult.errors };
    }
    const supergraphSchema = mergeResult.supergraph;
    const supergraphQueryGraph = (0, query_graphs_1.buildSupergraphAPIQueryGraph)(supergraphSchema);
    const federatedQueryGraph = (0, query_graphs_1.buildFederatedQueryGraph)(supergraphSchema, false);
    const { errors, hints } = (0, validate_1.validateGraphComposition)(supergraphSchema, supergraphQueryGraph, federatedQueryGraph);
    if (errors) {
        return { errors };
    }
    let supergraphSdl;
    try {
        supergraphSdl = (0, federation_internals_1.printSchema)(supergraphSchema, (_a = options.sdlPrintOptions) !== null && _a !== void 0 ? _a : (0, federation_internals_1.shallowOrderPrintedDefinitions)(federation_internals_1.defaultPrintOptions));
    }
    catch (err) {
        return { errors: [err] };
    }
    return {
        schema: supergraphSchema,
        supergraphSdl,
        hints: mergeResult.hints.concat(hints !== null && hints !== void 0 ? hints : []),
    };
}
exports.compose = compose;
function composeServices(services, options = {}) {
    const subgraphs = (0, federation_internals_1.subgraphsFromServiceList)(services);
    if (Array.isArray(subgraphs)) {
        return { errors: subgraphs };
    }
    return compose(subgraphs, options);
}
exports.composeServices = composeServices;
//# sourceMappingURL=compose.js.map