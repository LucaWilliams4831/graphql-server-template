import { CompositeType, FieldDefinition, Operation, Schema, SchemaRootKind } from "@apollo/federation-internals";
import { Edge, QueryGraph, RootPath, Transition, ConditionResolver, TransitionPathWithLazyIndirectPaths, RootVertex } from "@apollo/query-graphs";
import { CompositionHint } from "./hints";
import { GraphQLError } from "graphql";
export declare class ValidationError extends Error {
    readonly supergraphUnsatisfiablePath: RootPath<Transition>;
    readonly subgraphsPaths: RootPath<Transition>[];
    readonly witness: Operation;
    constructor(message: string, supergraphUnsatisfiablePath: RootPath<Transition>, subgraphsPaths: RootPath<Transition>[], witness: Operation);
}
export declare function validateGraphComposition(supergraphSchema: Schema, supergraphAPI: QueryGraph, subgraphs: QueryGraph): {
    errors?: GraphQLError[];
    hints?: CompositionHint[];
};
export declare function computeSubgraphPaths(supergraphSchema: Schema, supergraphPath: RootPath<Transition>, subgraphs: QueryGraph): {
    traversal?: ValidationState;
    isComplete?: boolean;
    error?: GraphQLError;
};
export declare function extractValidationError(error: any): ValidationError | undefined;
export declare class ValidationContext {
    readonly supergraphSchema: Schema;
    private readonly joinTypeDirective;
    private readonly joinFieldDirective;
    constructor(supergraphSchema: Schema);
    isShareable(field: FieldDefinition<CompositeType>): boolean;
}
export declare class ValidationState {
    readonly supergraphPath: RootPath<Transition>;
    readonly subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[];
    constructor(supergraphPath: RootPath<Transition>, subgraphPaths: TransitionPathWithLazyIndirectPaths<RootVertex>[]);
    static initial({ supergraphAPI, kind, subgraphs, conditionResolver, }: {
        supergraphAPI: QueryGraph;
        kind: SchemaRootKind;
        subgraphs: QueryGraph;
        conditionResolver: ConditionValidationResolver;
    }): ValidationState;
    validateTransition(context: ValidationContext, supergraphEdge: Edge): {
        state?: ValidationState;
        error?: GraphQLError;
        hint?: CompositionHint;
    };
    currentSubgraphNames(): string[];
    currentSubgraphs(): {
        name: string;
        schema: Schema;
    }[];
    toString(): string;
}
declare class ConditionValidationResolver {
    private readonly supergraphSchema;
    private readonly federatedQueryGraph;
    readonly resolver: ConditionResolver;
    constructor(supergraphSchema: Schema, federatedQueryGraph: QueryGraph);
    private validateConditions;
    private advanceState;
}
export {};
//# sourceMappingURL=validate.d.ts.map